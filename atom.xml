<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.top.com/"/>
  <updated>2017-12-24T04:08:01.823Z</updated>
  <id>http://www.top.com/</id>
  
  <author>
    <name>马文磊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM参数设置</title>
    <link href="http://www.top.com/2017/12/24/JVM%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"/>
    <id>http://www.top.com/2017/12/24/JVM参数设置/</id>
    <published>2017-12-24T07:23:50.000Z</published>
    <updated>2017-12-24T04:08:01.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-tomcat调优"><a href="#1-tomcat调优" class="headerlink" title="1.tomcat调优:"></a>1.tomcat调优:</h2><p>通过优化tomcat提高网站的并发能力。</p><p>1.优化配置在conf/ tomcat-users.xml下添加用户：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rolerolename="manager-gui"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"admin"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rolerolename="admin-gui"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"tomcat"</span> <span class="attr">password</span>=<span class="string">"tomcat"</span><span class="attr">roles</span>=<span class="string">"admin-gui,admin,manager-gui,manager"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>启动tomcat，登录查看信息：<a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a></p><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/4JG15lBAf3.png?imageslim" alt="mark"></p><p>tomcat的运行模式有3种：</p><p>1、  bio<br>默认的模式,性能非常低下,没有经过任何优化处理和支持.</p><p>2、  nio<br>==nio(new I/O)，是Java SE 1.4及后续版本提供的一种新的I/O操作方式(即java.nio包及其子包)。Java nio是一个基于缓冲区、并能提供非阻塞I/O操作的Java API，因此nio也被看成是non-blocking I/O的缩写。它拥有比传统I/O操作(bio)更好的并发运行性能。==</p><p>3、  apr<br>安装起来最困难,但是从操作系统级别来解决异步的IO问题,大幅度的提高性能.</p><h2 id="2-启动NIO模式"><a href="#2-启动NIO模式" class="headerlink" title="2 .启动NIO模式"></a>2 .启动NIO模式</h2><p>修改server.xml里的Connector节点,修改protocol为org.apache.coyote.http11.Http11NioProtocol</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span>   <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>    <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span>  <span class="attr">redirectPort</span>=<span class="string">"8443"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-执行器（线程池）"><a href="#3-执行器（线程池）" class="headerlink" title="3.执行器（线程池）"></a>3.执行器（线程池）</h2><p>在tomcat中每一个用户请求都是一个线程，所以可以使用线程池提高性能。</p><p>开启并且使用</p><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/4m3bhaFHK2.png?imageslim" alt="mark"></p><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/G3JAla02a2.png?imageslim" alt="mark"></p><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><table><thead><tr><th>Attribute</th><th>Description</th></tr></thead><tbody><tr><td>threadPriority  （优先级）</td><td>(int) The thread priority for threads in the executor,  the default is <code>5</code> (the value of the<code>Thread.NORM_PRIORITY</code> constant)</td></tr><tr><td>daemon（守护进程）</td><td>(boolean) Whether the threads should be daemon threads or  not, the default is <code>true</code></td></tr><tr><td>namePrefix（名称前缀）</td><td>(String) The name prefix for each thread created by the  executor. The thread name for an individual thread will be <code>namePrefix+threadNumber</code></td></tr><tr><td>maxThreads（最大线程数）</td><td>(int) The max number of active threads in this pool,  default is <code>200</code></td></tr><tr><td>minSpareThreads（最小活跃线程数）</td><td>(int) The minimum number of threads always kept alive,  default is <code>25</code></td></tr><tr><td>maxIdleTime(空闲线程等待时间)</td><td>(int) The number of milliseconds before an idle thread  shutsdown, unless the number of active threads are less or equal to  minSpareThreads. Default value is <code>60000</code>(1 minute)</td></tr><tr><td>maxQueueSize（最大的等待队里数，超过则请求拒绝）</td><td>(int) The maximum number of runnable tasks that can queue  up awaiting execution before we reject them. Default value is <code>Integer.MAX_VALUE</code></td></tr><tr><td>prestartminSpareThreads（是否在启动时就生成minSpareThreads个线程）</td><td>(boolean) Whether minSpareThreads should be started when  starting the Executor or not, the default is <code>false</code></td></tr><tr><td>threadRenewalDelay（重建线程的时间间隔）</td><td>(long) If a <a href="http://127.0.0.1:8080/docs/config/listeners.html" target="_blank" rel="noopener">ThreadLocalLeakPreventionListener</a> is configured, it will notify this  executor about stopped contexts. After a context is stopped, threads in the  pool are renewed. To avoid renewing all threads at the same time, this option  sets a delay between renewal of any 2 threads. The value is in ms, default  value is <code>1000</code> ms. If value is negative, threads  are not renewed.  。重建线程池内的线程时，为了避免线程同时重建，每隔threadRenewalDelay（单位： ms ）重建一个线程。默认值为1000 ，设置为负则不重建</td></tr></tbody></table><h2 id="4-连接器（Connector）"><a href="#4-连接器（Connector）" class="headerlink" title="4. 连接器（Connector）"></a>4. 连接器（Connector）</h2><p>Connector是Tomcat接收请求的入口，每个Connector有自己专属的监听端口</p><p>Connector有两种：HTTP Connector和AJPConnector</p><p>…….</p><p>这里东西很多   具体看 文档</p><h2 id="5-禁用AJP连接器"><a href="#5-禁用AJP连接器" class="headerlink" title="5.禁用AJP连接器    "></a>5.禁用AJP连接器    </h2><p>AJP（Apache JServerProtocol）</p><p>AJPv13协议是面向包的。WEB服务器和Servlet容器通过TCP连接来交互；为了节省SOCKET创建的昂贵代价，WEB服务器会尝试维护一个永久TCP连接到servlet容器，并且在多个请求和响应周期过程会重用连接。</p><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/g3mc2K6aHg.png?imageslim" alt="mark"></p><p>我们一般是使用Nginx+tomcat的架构，所以用不着AJP协议，所以把AJP连接器禁用。</p><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/meDmH1D599.png?imageslim" alt="mark"></p><p>在管理界面中看不到ajp了：</p><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/kHaGCDg8Kk.png?imageslim" alt="mark"></p><h2 id="6-JVM参数的优化"><a href="#6-JVM参数的优化" class="headerlink" title="6.JVM参数的优化"></a>6.JVM参数的优化</h2><p>适当调整Tomcat的运行JVM参数可以提升整体性能</p><h3 id="6-1-JVM内存模型"><a href="#6-1-JVM内存模型" class="headerlink" title="6.1 JVM内存模型"></a>6.1 JVM内存模型</h3><h4 id="6-1-1-Java栈"><a href="#6-1-1-Java栈" class="headerlink" title="6.1.1.  Java栈"></a>6.1.1.  Java栈</h4><p>​    Java栈是与每一个线程关联的，JVM在创建每一个线程的时候，会分配一定的栈空间给线程。它主要用来存储线程执行过程中的局部变量，方法的返回值，以及方法调用上下文。栈空间随着线程的终止而释放。</p><h4 id="6-1-2-Java堆"><a href="#6-1-2-Java堆" class="headerlink" title="6.1.2.  Java堆"></a>6.1.2.  Java堆</h4><p>​    Java中堆是由所有的线程共享的一块内存区域，堆用来保存各种JAVA对象，比如数组，线程对象等。</p><h4 id="6-1-3-Java堆的分区"><a href="#6-1-3-Java堆的分区" class="headerlink" title="6.1.3.  Java堆的分区"></a>6.1.3.  Java堆的分区</h4><p>​    JVM堆一般又可以分为以下三部分：</p><p>​    <img src="http://ozaomob5f.bkt.clouddn.com/images/171224/mH4k11bkBl.png?imageslim" alt="mark"></p><p>◆ Young 年轻区（代）</p><p>Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用，在Eden区间变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。</p><p>◆ Tenured 年老区</p><p>Tenued区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区，一般如果系统中用了application级别的缓存，缓存中的对象往往会被转移到这一区间。</p><p>◆ Perm 永久区</p><p>Perm代主要保存class,method,filed对象，这部份的空间一般不会溢出，除非一次性加载了很多的类，不过在涉及到热部署的应用服务器的时候，有时候会遇到java.lang.OutOfMemoryError : PermGen space 的错误，造成这个错误的很大原因就有可能是每次都重新部署，但是重新部署后，类的class没有被卸载掉，这样就造成了大量的class对象保存在了perm中，这种情况下，一般重新启动应用服务器可以解决问题。</p><p>Virtual区：</p><p>最大内存和初始内存的差值，就是Virtual区。</p><h4 id="6-1-4-设置区大小"><a href="#6-1-4-设置区大小" class="headerlink" title="6.1.4.设置区大小"></a>6.1.4.设置区大小</h4><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/d862eA712H.png?imageslim" alt="mark"></p><p>◆ Total Heap</p><p>-Xms ：指定了JVM初始启动以后初始化内存</p><p>-Xmx：指定JVM堆得最大内存，在JVM启动以后，会分配-Xmx参数指定大小的内存给JVM，但是不一定全部使,JVM会根据-Xms参数来调节真正用于JVM的内存</p><p>-Xmx -Xms之差就是三个Virtual空间的大小</p><p>◆ Young Generation</p><p>-XX:NewRatio=8意味着tenured 和 young的比值8：1，这样eden+2*survivor=1/9</p><p>堆内存</p><p>-XX:SurvivorRatio=32意味着eden和一个survivor的比值是32：1，这样一个Survivor就占Young区的1/34.</p><p>-Xmn 参数设置了年轻代的大小</p><p>◆ Perm Generation</p><p>-XX:PermSize=16M -XX:MaxPermSize=64M</p><p>Thread Stack</p><p>-XX:Xss=128K</p><h3 id="6-2-常用参数"><a href="#6-2-常用参数" class="headerlink" title="6.2. 常用参数"></a>6.2. 常用参数</h3><p>修改文件：bin/catalina.sh</p><p>JAVA_OPTS=”-Dfile.encoding=UTF-8-server -Xms1024m -Xmx1024m -XX:NewSize=512m -XX:MaxNewSize=512m-XX:PermSize=256m -XX:MaxPermSize=256m -XX:NewRatio=2-XX:MaxTenuringThreshold=50 -XX:+DisableExplicitGC”</p><p>参数说明：</p><p>1、  file.encoding 默认文件编码</p><p>2、  -Xmx1024m  设置JVM最大可用内存为1024MB</p><p>3、  -Xms1024m  设置JVM最小内存为1024m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p><p>4、  -XX:NewSize  设置年轻代大小</p><p>5、  XX:MaxNewSize 设置最大的年轻代大小</p><p>6、  -XX:PermSize  设置永久代大小</p><p>7、  -XX:MaxPermSize 设置最大永久代大小</p><p>8、  -XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与终身代的比值（除去永久代）。设置为4，则年轻代与终身代所占比值为1：4，年轻代占整个堆栈的1/5</p><p>9、  -XX:MaxTenuringThreshold=0：设置垃圾最大年龄，默认为：15。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</p><p>10、             -XX:+DisableExplicitGC这个将会忽略手动调用GC的代码使得System.gc()的调用就会变成一个空调用，完全不会触发任何GC</p><h3 id="6-3-在tomcat中设置JVM参数"><a href="#6-3-在tomcat中设置JVM参数" class="headerlink" title="6.3. 在tomcat中设置JVM参数"></a>6.3. 在tomcat中设置JVM参数</h3><h4 id="6-3-1-linux"><a href="#6-3-1-linux" class="headerlink" title="6.3.1.  linux"></a>6.3.1.  linux</h4><p>修改bin/catalina.sh文件参数（第一行）</p><p>JAVA_OPTS=”-Dfile.encoding=UTF-8-server -Xms1024m -Xmx2048m -XX:NewSize=512m -XX:MaxNewSize=1024m-XX:PermSize=256m -XX:MaxPermSize=256m -XX:MaxTenuringThreshold=10-XX:NewRatio=2 -XX:+DisableExplicitGC”</p><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/9Hhig3kk9B.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-tomcat调优&quot;&gt;&lt;a href=&quot;#1-tomcat调优&quot; class=&quot;headerlink&quot; title=&quot;1.tomcat调优:&quot;&gt;&lt;/a&gt;1.tomcat调优:&lt;/h2&gt;&lt;p&gt;通过优化tomcat提高网站的并发能力。&lt;/p&gt;
&lt;p&gt;1.优化配置在c
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.top.com/tags/java/"/>
    
      <category term="垃圾回收" scheme="http://www.top.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
      <category term="tomcat优化" scheme="http://www.top.com/tags/tomcat%E4%BC%98%E5%8C%96/"/>
    
      <category term="jvm参数" scheme="http://www.top.com/tags/jvm%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java垃圾回收机制</title>
    <link href="http://www.top.com/2017/12/24/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://www.top.com/2017/12/24/JVM垃圾回收/</id>
    <published>2017-12-24T02:23:50.000Z</published>
    <updated>2017-12-24T02:56:44.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h1><h2 id="1-对于Java的GC哪些内存需要回收"><a href="#1-对于Java的GC哪些内存需要回收" class="headerlink" title="1.对于Java的GC哪些内存需要回收"></a>1.对于Java的GC哪些内存需要回收</h2><p>​    内存运行时JVM会有一个运行时数据区来管理内存.主要包括5大部分: 程序计数器(Program Counter Register) ,虚拟机栈(JVM Stack) , 本地方法栈(Native Method Stack), 方法区(Method Area) , 堆(Heap) .</p><p>​    而其中程序计数器,虚拟机栈,本地方法栈是每个线程私有的内存空间,随线程而生,随线程而死亡.列如栈中的每一个栈帧中分配多少内存基本上在类结构确定是哪个就已知了,因此3个区域的内存分配和回收都是确定的,无需考虑内存回收的问题.</p><p>​    但是方法区和堆就不同了,一个接口的多个实现类需要的内存可能不一样,我们在运行期间才会知道会创建哪些对象,这部分内存的分配和回收都是动态的,GC主要关注的就是这部分内存</p><p>​    </p><h2 id="2-Java-的-GC-什么时候回收垃圾"><a href="#2-Java-的-GC-什么时候回收垃圾" class="headerlink" title="2.Java 的 GC 什么时候回收垃圾 "></a>2.Java 的 GC 什么时候回收垃圾 </h2><p>在面试中经常会碰到这样一个问题（事实上笔者也碰到过） ：如何判断一个对象已经死去？<br>很容易想到的一个答案是：对一个对象添加引用计数器。每当有地方引用它时，计数器值加 1；当引用失效时，计<br>数器值减 1.而当计数器的值为 0 时这个对象就不会再被使用，判断为已死。是不是简单又直观。然而，很遗憾。这种做法是错误的！为什么是错的呢？事实上，用引用计数法确实在大部分情况下是一个不错的解决方案，而在实际的应用中也有不少案例，但它却无法解决对象之间的循环引用问题。比如对象 A 中有一个字段指向了对象 B，而对象 B 中也有一个字段指向了对象 A，而事实上他们俩都不再使用，但计数器的值永远都不可能为 0，也就不会被回收，然后就发生了内存泄露。<br>所以，正确的做法应该是怎样呢？</p><p>在 Java， C#等语言中，比较主流的判定一个对象已死的方法是：可达性分析(Reachability Analysis).<br>所有生成的对象都是一个称为”GC Roots”的根的子树。从 GC Roots 开始向下搜索，搜索所经过的路径称为引用链<br>(Reference Chain)，当一个对象到 GC Roots 没有任何引用链可以到达时，就称这个对象是不可达的（不可引用的），也就是可以被 GC 回收了。</p><p>无论是引用计数器还是可达性分析，判定对象是否存活都与引用有关！那么，如何定义对象的引用呢？<br>我们希望给出这样一类描述：当内存空间还够时，能够保存在内存中；如果进行了垃圾回收之后内存空间仍旧非<br>常紧张，则可以抛弃这些对象。所以根据不同的需求，给出如下四种引用，根据引用类型的不同， GC 回收时也会有不同的操作：<br>1)强引用(Strong Reference):Object obj = new Object();只要强引用还存在， GC 永远不会回收掉被引用的对象。</p><p>2)软引用(Soft Reference)：描述一些还有用但非必需的对象。在系统将会发生内存溢出之前，会把这些对象列入<br>回收范围进行二次回收（即系统将会发生内存溢出了，才会对他们进行回收。</p><p>3)弱引用(Weak Reference):程度比软引用还要弱一些。这些对象只能生存到下次 GC 之前。当 GC 工作时，无论内<br>存是否足够都会将其回收（即只要进行 GC，就会对他们进行回收)</p><p>4)虚引用(Phantom Reference):一个对象是否存在虚引用，完全不会对其生存时间构成影响。<br>关于方法区中需要回收的是一些废弃的常量和无用的类。</p><p>1.废弃的常量的回收。这里看引用计数就可以了。没有对象引用该常量就可以放心的回收了。<br>2.无用的类的回收。什么是无用的类呢？<br>A.该类所有的实例都已经被回收。也就是 Java 堆中不存在该类的任何实例；<br>B.加载该类的 ClassLoader 已经被回收；<br>C.该类对应的 java.lang.Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</p><p>总而言之:<br>​    对于堆中的对象，主要用可达性分析判断一个对象是否还存在引用，如果该对象没有任何引用就应该被回收。而根据我们实际对引用的不同需求，又分成了 4 中引用，每种引用的回收机制也是不同的。对于方法区中的常量和类，当一个常量没有任何对象引用它，它就可以被回收了。而对于类，如果可以判定它为无用类，就可以被回收了。 </p><h2 id="3-JVM内存模型"><a href="#3-JVM内存模型" class="headerlink" title="3. JVM内存模型"></a>3. JVM内存模型</h2><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/l2CbHmh9GL.png?imageslim" alt="mark"></p><h2 id="4-java虚拟机JVM垃圾收集算法有四种："><a href="#4-java虚拟机JVM垃圾收集算法有四种：" class="headerlink" title="4. java虚拟机JVM垃圾收集算法有四种："></a>4. java虚拟机JVM垃圾收集算法有四种：</h2><ol><li><p>标记-清除算法</p><p> 这是JVM最基础的垃圾收集算法。 该算法分为两个阶段：“标记”和“清除”。首先标记处所有需要回收的对象，然后统一清除被标记的对象。 该算法，标记和清除两个阶段的效率不高。此外，回收后会产生大量的不连续的内存碎片，进一步会导致垃圾回收次数的增加。</p><p> <img src="http://ozaomob5f.bkt.clouddn.com/images/171224/k2emL7Bg3k.png?imageslim" alt="mark"></p></li><li><p>复制算法</p><p>​     为了解决标记-清除算法的效率问题，出现了复制算法，如下图： 该算法的思想是将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，则将还存活的对象复制到另外一块内存上去，然后再把刚使用过的内存空间一次清理掉。从而达到了每次垃圾回收时只是针对其中一块，避免了产生内存碎片等情况。该算法的代价是只是使用了其中一本的内存，代价有点高。</p><p>​      随着研究的不断发现，商业虚拟机在该算法中不断进行优化尝试。比如在HotSpot虚拟机中，新生代中Eden和Survivor的大小比例为8：:1，因为新生代的对象需要回收的概率大（对象的生命周期短，存活率低），所以内存的可用率达到了90%（新生代分为：Eden和两块Survivor）。每次都是把Eden和Survivor中存活的对象拷贝到另一块Survivor中，然后清理掉Eden和Survivor空间。</p><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/Bl47HFhdl2.png?imageslim" alt="mark"></p></li><li><p>标记-整理算法</p><p>  当复制收集算法面对的回收对象为存活率较高的情况时，要执行较多的复制操作，效率会变低。为了提高这些对象垃圾回收效率，充分利用可用内存，标记-整理算法出现了。如下图：</p><p>​        <img src="http://ozaomob5f.bkt.clouddn.com/images/171224/BjjDaB3i30.png?imageslim" alt="mark"></p><p>​      该算法集成了标记-清除和复制收集算法的优点。第一个阶段仍是进行标记，第二个阶段是把所有存活的对象都向一端移动，按顺序排放，然后直接清理掉端边界意外的内存。该算法避免了标记-清除的内存碎片问题以及复制算法的空间问题。该算法适合于老年代对象的回收。</p></li><li><p>分代收集算法</p><p>  这是目前大多数虚拟机采用的垃圾回收算法。基于对象的生命周期划分为新生代、老年代以及持久代。比如新生代就采用复制收集算法，而老年代就采用标记-清除或者标记-整理算法。如下图： 对于分代收集，虚拟机需要区分对象的分配年代，是放在新生代还是否放在老年代？。解决的办法是：jvm为每个对象定义了一个对象年龄计数器。如果对象在Eden出生并且经过第一次新生代GC（Minor GC）后仍然存活并且能被Survivor容纳，则该对象将被移动到另一块Survivor空间，并将对象年龄计数器加1。对象在Survivor区中每经历过一次Minor GC，年龄计数器就加1，当它的年龄达到设定的阈值（默认是15）时，则被移动到老年代中。阈值的设置通过参数-XX：MaxTenuringThreshold设置。</p><p>​      当然，并不是一定达到阈值才被移动到老年代，为了适应复杂的情况，动态的判定对象年龄，虚拟机规定：如果Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间的一半，对象的年龄大于或者等于该年龄的对象就可以直接进入老年代，不必等到达到设定的阈值。</p><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/kg7ggAJBj0.png?imageslim" alt="mark"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java垃圾回收机制&quot;&gt;&lt;a href=&quot;#Java垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;Java垃圾回收机制&quot;&gt;&lt;/a&gt;Java垃圾回收机制&lt;/h1&gt;&lt;h2 id=&quot;1-对于Java的GC哪些内存需要回收&quot;&gt;&lt;a href=&quot;#1-
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.top.com/tags/java/"/>
    
      <category term="垃圾回收" scheme="http://www.top.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>Solr开发</title>
    <link href="http://www.top.com/2017/12/15/Solr%E5%BC%80%E5%8F%91/"/>
    <id>http://www.top.com/2017/12/15/Solr开发/</id>
    <published>2017-12-15T14:27:08.000Z</published>
    <updated>2017-12-24T13:07:42.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Solr单机版的使用"><a href="#Solr单机版的使用" class="headerlink" title="Solr单机版的使用"></a>Solr单机版的使用</h1><p>在虚拟机上模拟solr单机版和集群的使用,和实际开发其实是差不多的</p><p>准备tomcat  solr的安装包</p><h2 id="1-安装单机版的solr"><a href="#1-安装单机版的solr" class="headerlink" title="1.安装单机版的solr"></a>1.安装单机版的solr</h2><p> mkdir  singleSolr<br> 在singleSolr目录下<br> 导入apache-tomcat-7.0.52  解压   重命名为tomcat-solr<br> 导入solr-4.10.3.tgz.tgz  tar zxvf  solr-4.10.3.tgz.tgz  </p><h2 id="2-部署solr"><a href="#2-部署solr" class="headerlink" title="2.部署solr"></a>2.部署solr</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">把war包放入 tomcat  webapp</span><br><span class="line">cp solr-4.10.3/example/webapps/solr.war  tomcat-solr/webapps/</span><br></pre></td></tr></table></figure><h2 id="3-导入依赖jar包"><a href="#3-导入依赖jar包" class="headerlink" title="3.导入依赖jar包"></a>3.导入依赖jar包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd solr-4.10.3/example/lib/ext/</span><br><span class="line">把ext下的所有jar包  复制到tomcat-solr/webapps/solr/WEB-INF/lib/</span><br><span class="line">复制到cp -r solr-4.10.3/example/lib/ext/*  tomcat-solr/webapps/solr/WEB-INF/lib/</span><br></pre></td></tr></table></figure><h2 id="4-拷贝solr-4-10-3-example-solr到-singleSolr目录下"><a href="#4-拷贝solr-4-10-3-example-solr到-singleSolr目录下" class="headerlink" title="4.拷贝solr-4.10.3/example/solr到  singleSolr目录下"></a>4.拷贝solr-4.10.3/example/solr到  singleSolr目录下</h2><p>这一步是配置仓库的路径</p><pre><code>cp -r solr-4.10.3/example/solr   .    注意 . 代表当前目录windows下配置 catalina.bat  set JAVA_OPTS=-&quot;Dsolr.solr.home=E:\solr&quot;Linux下配置   catalina.sh   export JAVA_OPTS =&quot;-Dsolr.solr.home=/usr/local/hadoop/singleSolr/solr/&quot;</code></pre><h2 id="5-依赖类库"><a href="#5-依赖类库" class="headerlink" title="5.依赖类库"></a>5.依赖类库</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd solr-4.10.3/   </span><br><span class="line">拷贝solr-4.10./3 下的  contrib   contrib</span><br><span class="line">到4中的索引库目录下</span><br><span class="line">命令: cd  singleSolr/solr</span><br><span class="line">  cp  -r  ../solr-4.10.3/contrib/  ../solr-4.10.3/dist/  .    </span><br><span class="line">   不要忘记. 当前目录(singleSolr/solr)  ---&gt; 索引库的目录</span><br></pre></td></tr></table></figure><h2 id="6-修改索引库下的配置-singleSolr-solr"><a href="#6-修改索引库下的配置-singleSolr-solr" class="headerlink" title="6.修改索引库下的配置(singleSolr/solr)"></a>6.修改索引库下的配置(singleSolr/solr)</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mv collection1 item   --把索引库名字改成item</span><br><span class="line">cd  item/</span><br><span class="line">vim  core.properties   把name=collection1改为name=item</span><br><span class="line">这样索引库的名字才是修改成功了</span><br><span class="line"></span><br><span class="line">再修改配置文件</span><br><span class="line">cd  item/conf</span><br><span class="line">修改 item/conf下的   vim solrconfig.xml</span><br></pre></td></tr></table></figure><p>  修改引入jar包的位置 </p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;solr.install.dir:..&#125;/contrib/extraction/lib"</span> <span class="attr">regex</span>=<span class="string">".*\.jar"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;solr.install.dir:..&#125;/dist/"</span> <span class="attr">regex</span>=<span class="string">"solr-cell-\d.*\.jar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;solr.install.dir:..&#125;/contrib/clustering/lib/"</span> <span class="attr">regex</span>=<span class="string">".*\.jar"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;solr.install.dir:..&#125;/dist/"</span> <span class="attr">regex</span>=<span class="string">"solr-clustering-\d.*\.jar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;solr.install.dir:..&#125;/contrib/langid/lib/"</span> <span class="attr">regex</span>=<span class="string">".*\.jar"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;solr.install.dir:..&#125;/dist/"</span> <span class="attr">regex</span>=<span class="string">"solr-langid-\d.*\.jar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;solr.install.dir:..&#125;/contrib/velocity/lib"</span> <span class="attr">regex</span>=<span class="string">".*\.jar"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;solr.install.dir:..&#125;/dist/"</span> <span class="attr">regex</span>=<span class="string">"solr-velocity-\d.*\.jar"</span> /&gt;</span></span><br></pre></td></tr></table></figure><pre><code>这一步做个说明  这个是solr的索引库的位置export JAVA_OPTS =&quot;-Dsolr.solr.home=/usr/local/hadoop/singleSolr/solr/&quot;</code></pre><h2 id="7-启动solr服务-查看是否配置成功"><a href="#7-启动solr服务-查看是否配置成功" class="headerlink" title="7.启动solr服务  查看是否配置成功"></a>7.启动solr服务  查看是否配置成功</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh  tomcat-solr/bin/startup.sh       -- 启动sol服务</span><br><span class="line">tail -f  tomcat-solr/logs/catalina.out -- 查看进程</span><br></pre></td></tr></table></figure><h2 id="8-安装ak分词器"><a href="#8-安装ak分词器" class="headerlink" title="8.安装ak分词器"></a>8.安装ak分词器</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">首先需要在项目下导入jar包</span><br><span class="line">cd  /usr/local/hadoop/singleSolr/tomcat-solr/webapps/solr/WEB-INF/lib</span><br><span class="line"></span><br><span class="line">导入分词器的 jar包      IKAnalyzer2012FF_u1.jar</span><br><span class="line"></span><br><span class="line">在/usr/local/hadoop/singleSolr/tomcat-solr/webapps/solr/WEB-INF下导入分词器的配置文件</span><br><span class="line"></span><br><span class="line">创建  classes 文件夹(如过没有的话)</span><br><span class="line">ext.dic</span><br><span class="line">IKAnalyzer.cfg.xml</span><br><span class="line">log4j.properties</span><br><span class="line">stopword.dic</span><br><span class="line"></span><br><span class="line"> Ik分词器的环境准备好了</span><br></pre></td></tr></table></figure><h2 id="9-再去配置索引仓库"><a href="#9-再去配置索引仓库" class="headerlink" title="9.再去配置索引仓库"></a>9.再去配置索引仓库</h2><pre><code>/usr/local/hadoop/singleSolr/solr/item/conf  下的 schema.xml </code></pre><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置域字段类型,测试是否配置成功 --&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 域字段  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"username_ik"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置域类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"text_ik"</span> <span class="attr">class</span>=<span class="string">"solr.TextField"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">class</span>=<span class="string">"org.wltea.analyzer.lucene.IKAnalyzer"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldType</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置好 --&gt;</span></span><br><span class="line"> sh tomcat-solr/bin/shutdown.sh</span><br><span class="line"><span class="comment">&lt;!--  让配置生效 --&gt;</span></span><br><span class="line"> sh tomcat-solr/bin/startup.sh</span><br><span class="line"><span class="comment">&lt;!--  查看进程 --&gt;</span></span><br><span class="line">tail -f tomcat-solr/logs/catalina.out</span><br></pre></td></tr></table></figure><h2 id="10-要导入索引库"><a href="#10-要导入索引库" class="headerlink" title="10.要导入索引库"></a>10.要导入索引库</h2><p>问题1:</p><pre><code>首先要配置索引域字段(创建数据库字段)应该把参与搜索的数据库数据导入索引库确定参与搜索字段:    商品表:id,title,sell_point,price,image    商品描述表:item_desc    商品分类表:category_name</code></pre><p>把以上三张表数据导入索引库,实现搜索业务<br>问题2:配置索引域字段<br>    一个字段对应需求导入索引库数据库的一个字段</p><p>导入数据的过程:<br>    1.查询数据库(三张表)<br>    2.把查询数据库写入索引库</p><p>注意:查询时要注意商品的状态<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">a.id,</span><br><span class="line">a.title,</span><br><span class="line">a.sell_point,</span><br><span class="line">a.price,</span><br><span class="line">a.image,</span><br><span class="line">b.item_desc,</span><br><span class="line">c.name category_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  tb_item a,</span><br><span class="line">  tb_item_desc b,</span><br><span class="line"> tb_item_cat c</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">a.id = b.item_id</span><br><span class="line"><span class="keyword">AND</span></span><br><span class="line">a.cid = c.id </span><br><span class="line"><span class="keyword">AND</span></span><br><span class="line">a.status = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>索引域字段的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;field name=&quot;item_title&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;</span><br><span class="line">&lt;field name=&quot;item_sell_point&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;</span><br><span class="line">&lt;field name=&quot;item_price&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;</span><br><span class="line">&lt;field name=&quot;item_image&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; /&gt;</span><br><span class="line">&lt;field name=&quot;item_category_name&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;</span><br><span class="line">&lt;field name=&quot;item_desc&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; /&gt;</span><br><span class="line">&lt;field name=&quot;item_keywords&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt;</span><br><span class="line">&lt;copyField source=&quot;item_title&quot; dest=&quot;item_keywords&quot;/&gt;</span><br><span class="line">&lt;copyField source=&quot;item_sell_point&quot; dest=&quot;item_keywords&quot;/&gt;</span><br><span class="line">&lt;copyField source=&quot;item_category_name&quot; dest=&quot;item_keywords&quot;/&gt;</span><br><span class="line">&lt;copyField source=&quot;item_desc&quot; dest=&quot;item_keywords&quot;/&gt;</span><br></pre></td></tr></table></figure><p>​<br>工作1:配置索引域字段—(创建数据库表字段)<br>问题1:应该把哪些数据导入索引库?</p><pre><code>应该把参与搜索的数据库数据导入索引库确定参与搜索字段商品表:id,title,sell_point,price,image商品描述表:item_desc商品分类表:category_name以上三张表数据导入索引库,实现搜索业务</code></pre><p>问题2:配置索引域字段<br>    一个字段对应需求导入索引库</p><pre><code>导入数据过程:    </code></pre><p>1.创建SearchItemMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 查询索引库域字段对应数据库值写入索引库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.e3.search.mapper.SearchItemMapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findDataBaseToSolrIndex"</span> <span class="attr">resultType</span>=<span class="string">"searchItem"</span>&gt;</span></span><br><span class="line">SELECT</span><br><span class="line">a.id,</span><br><span class="line">a.title,</span><br><span class="line">a.sell_point,</span><br><span class="line">a.price,</span><br><span class="line">a.image,</span><br><span class="line">b.item_desc,</span><br><span class="line">c.name category_name</span><br><span class="line">FROM</span><br><span class="line">tb_item a,</span><br><span class="line">tb_item_desc b,</span><br><span class="line">tb_item_cat c</span><br><span class="line">WHERE</span><br><span class="line">a.id = b.item_id</span><br><span class="line">AND</span><br><span class="line">a.cid = c.id</span><br><span class="line">AND</span><br><span class="line">a.status = 1;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.查询索引域字段对应数据值写入索引库   业务代码的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求:查询索引域字段对应数据值写入索引库</span></span><br><span class="line"><span class="comment"> * 参数:无</span></span><br><span class="line"><span class="comment"> * 返回值:E3mallResult </span></span><br><span class="line"><span class="comment"> * 发布服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E3mallResult <span class="title">findDataBaseToSolrIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">List&lt;SearchItem&gt; list = searchItemMapper.findDataBaseToSolrIndex();</span><br><span class="line"><span class="comment">//循环集合数据,把数据封装到doc文档对象,实现索引库的写入</span></span><br><span class="line"><span class="keyword">for</span> (SearchItem searchItem : list) &#123;</span><br><span class="line"><span class="comment">//创建一个文档对象,封装索引库域字段对应的值</span></span><br><span class="line">SolrInputDocument doc = <span class="keyword">new</span> SolrInputDocument();</span><br><span class="line"><span class="comment">//封装文档域所对应的值</span></span><br><span class="line">doc.addField(<span class="string">"id"</span>, searchItem.getId());</span><br><span class="line"><span class="comment">//标题</span></span><br><span class="line">doc.addField(<span class="string">"item_title"</span>, searchItem.getTitle());</span><br><span class="line"><span class="comment">//卖点</span></span><br><span class="line">doc.addField(<span class="string">"item_sell_point"</span>, searchItem.getSell_point());</span><br><span class="line"><span class="comment">//价格</span></span><br><span class="line">doc.addField(<span class="string">"item_price"</span>, searchItem.getPrice());</span><br><span class="line"><span class="comment">//图片地址</span></span><br><span class="line">doc.addField(<span class="string">"item_image"</span>, searchItem.getImage());</span><br><span class="line"><span class="comment">//商品分类名称  item_category_name</span></span><br><span class="line">doc.addField(<span class="string">"item_category_name"</span>, searchItem.getCategory_name());</span><br><span class="line"><span class="comment">//商品描述  item_desc  </span></span><br><span class="line">doc.addField(<span class="string">"item_desc"</span>, searchItem.getItem_desc());</span><br><span class="line"><span class="comment">//写入索引库</span></span><br><span class="line">solrServer.add(doc);</span><br><span class="line">&#125;</span><br><span class="line">solrServer.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="keyword">return</span> E3mallResult.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Solr集群版的使用"><a href="#Solr集群版的使用" class="headerlink" title="Solr集群版的使用"></a>Solr集群版的使用</h1><h2 id="zookeeper原理"><a href="#zookeeper原理" class="headerlink" title="zookeeper原理:"></a>zookeeper原理:</h2><p>概念:zookeeper是一个服务协调者</p><h3 id="1-注册中心-分布式服务"><a href="#1-注册中心-分布式服务" class="headerlink" title="1.注册中心(分布式服务)"></a>1.注册中心(分布式服务)</h3><p>​    把对象注册到注册中心,让服务消费者和服务提供者解耦合<br>​    让服务消费者和服务器提供者实现异步调用</p><h3 id="2-配置中心-集群服务-本地模拟实现"><a href="#2-配置中心-集群服务-本地模拟实现" class="headerlink" title="2.配置中心(集群服务)   本地模拟实现:"></a>2.配置中心(集群服务)   本地模拟实现:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x.  6 root root      4096 12月 11 00:39 solr1</span><br><span class="line">drwxr-xr-x.  6 root root      4096 12月 11 00:39 solr2</span><br><span class="line">drwxr-xr-x.  6 root root      4096 12月 11 00:39 solr3</span><br><span class="line">drwxr-xr-x.  6 root root      4096 12月 11 00:39 solr4</span><br><span class="line">drwxr-xr-x.  9 root root      4096 12月 11 00:36 tomcat1</span><br><span class="line">drwxr-xr-x.  9 root root      4096 12月 11 00:38 tomcat2</span><br><span class="line">drwxr-xr-x.  9 root root      4096 12月 11 00:38 tomcat3</span><br><span class="line">drwxr-xr-x.  9 root root      4096 12月 11 00:38 tomcat4</span><br><span class="line">drwxr-xr-x. 10 git  games     4096 11月  5 2012 zookeeper1</span><br><span class="line">drwxr-xr-x. 10 root root      4096 12月 11 00:35 zookeeper2</span><br><span class="line">drwxr-xr-x. 10 root root      4096 12月 11 00:35 zookeeper3</span><br></pre></td></tr></table></figure><p>配置集群redis集群<br>cd zookeeper1/conf  下<br>mv zoo_sample.cfg  zoo.cfg</p><p>修改这三行:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataDir=<span class="regexp">/usr/</span>local<span class="regexp">/hadoop/</span>clusterSolr<span class="regexp">/zookeeper1/</span>data</span><br><span class="line">dataLogDir=<span class="regexp">/usr/</span>local<span class="regexp">/hadoop/</span>clusterSolr<span class="regexp">/zookeeper1/</span>log</span><br><span class="line">clientPort=<span class="number">2182</span></span><br></pre></td></tr></table></figure><p>配置集群之间通信:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server<span class="meta">.1</span>=<span class="number">192.168</span><span class="meta">.65</span><span class="meta">.150</span>:<span class="number">2881</span>:<span class="number">3881</span></span><br><span class="line">server<span class="meta">.2</span>=<span class="number">192.168</span><span class="meta">.65</span><span class="meta">.150</span>:<span class="number">2882</span>:<span class="number">3882</span></span><br><span class="line">server<span class="meta">.3</span>=<span class="number">192.168</span><span class="meta">.65</span><span class="meta">.150</span>:<span class="number">2883</span>:<span class="number">3883</span></span><br></pre></td></tr></table></figure><p>在zookeeper1下创建data和log<br>在data目录下<br> touch myid<br>  vim myid    写入:1<br>在zookeeper2下创建data和log<br>在data目录下<br> touch myid<br> vim myid    写入:2<br>在zookeeper3下创建data和log<br>在data目录下<br> touch myid<br> vim myid    写入:3<br>三台同样操作</p><h3 id="3-配置tomcat集群"><a href="#3-配置tomcat集群" class="headerlink" title="3.配置tomcat集群"></a>3.配置tomcat集群</h3><p>1.tomcat1<br>    vim tomcat1/conf/server.xml<br>    修给端口:  8010 9000  8011</p><p>2.指定索引库的路径<br>设置tomcat启动时,启动solr,加载solr索引库的位置,还有zookeer的集群服务器地址IP<br>vim tomcat1/bin/catalina.sh<br>在catalina.sh中:<br>    export JAVA_OPTS =”-Dsolr.solr.home=/usr/local/hadoop/clusterSolr/solr1/ -DzkHost=192.168.65.150:2182,192.1<br>            68.65.150:2183,192.168.65.150:2184”<br>在配置tomcat1中的solr对应索引库solr1下:<br>vim   solr1/solr.xml<br>让监控端口和tomcat的启动端口一致</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">int</span> <span class="attr">name</span>=<span class="string">"hostPort"</span>&gt;</span>$&#123;jetty.port:9000&#125;<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重复4次上面的操作  修改相应的位置<br>8010 9001  8011<br>8012 9002  8013<br>8014 9003  8015<br>8016 9004  8017</p><p>把 solr 集群配置文件交给 Zookeeper 注册中心管理<br>把仓库核心配置文件放入 Zookeeper 注册中心， 当 solr 集群需要加载配置文件，只需要从 Zookeeper 中获取配置文件。<br>./zkcli.sh -zkhost 192.168.65.150:2182,192.168.65.150:2183,192.168.65.150:2184 -cmd upconfig -confdir /usr/local/hadoop/clusterSolr/solr1/item/conf/ -confname myconf</p><p>登录zookeeper集群:<br>命令:./zkCli.sh -server 192.168.65.150:2182<br>solr集群分片命令：<br><a href="http://192.168.65.150:9000/solr/admin/collections?action=CREATE&amp;name=products&amp;numShards=2&amp;replicationFactor=2&amp;maxShardsPerNode=8&amp;property.schema=schema.xml&amp;property.config=solrconfig.xml" target="_blank" rel="noopener">http://192.168.65.150:9000/solr/admin/collections?action=CREATE&amp;name=products&amp;numShards=2&amp;replicationFactor=2&amp;maxShardsPerNode=8&amp;property.schema=schema.xml&amp;property.config=solrconfig.xml</a><br>删除旧solrCloud集群分片：<br><a href="http://192.168.65.150:9000/solr/admin/collections?action=DELETE&amp;name=item" target="_blank" rel="noopener">http://192.168.65.150:9000/solr/admin/collections?action=DELETE&amp;name=item</a></p><p>这样的话,solr集群就搭建完成了<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Solr单机版的使用&quot;&gt;&lt;a href=&quot;#Solr单机版的使用&quot; class=&quot;headerlink&quot; title=&quot;Solr单机版的使用&quot;&gt;&lt;/a&gt;Solr单机版的使用&lt;/h1&gt;&lt;p&gt;在虚拟机上模拟solr单机版和集群的使用,和实际开发其实是差不多的&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="solr" scheme="http://www.top.com/tags/solr/"/>
    
      <category term="solr集群" scheme="http://www.top.com/tags/solr%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>Solr原理</title>
    <link href="http://www.top.com/2017/12/15/Solr%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://www.top.com/2017/12/15/Solr的原理/</id>
    <published>2017-12-15T14:27:08.000Z</published>
    <updated>2017-12-24T15:11:10.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lucene-amp-solr"><a href="#Lucene-amp-solr" class="headerlink" title="Lucene&amp;solr"></a>Lucene&amp;solr</h1><h2 id="1-Lucene简介"><a href="#1-Lucene简介" class="headerlink" title="1.Lucene简介"></a>1.Lucene简介</h2><p>​    Lucene是apache下的一个开放源代码的全文检索引擎工具包。提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能。</p><p>​    Lucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支 持和提供,Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻，   在Java开发环境里Lucene是一个成熟的免费开放源代码工具</p><p>​    ==Lucene并不是现成的搜索引擎产品，但可以用来制作搜索引擎产品==</p><h2 id="2-Lucene与搜索引擎的区别"><a href="#2-Lucene与搜索引擎的区别" class="headerlink" title="2. Lucene与搜索引擎的区别"></a>2. Lucene与搜索引擎的区别</h2><p>​    全文检索系统是按照全文检索理论建立起来的用于提供全文检索服务的软件系统，包括建立索引、处理查询返回结果集、增加索引、优化索引结构等功能。例如：百度搜索、eclipse帮助搜索、淘宝网商品搜索等。</p><p>​    搜索引擎是全文检索技术最主要的一个应用，例如百度。搜索引擎起源于传统的信息全文检索理论，即计算机程序通过扫描每一篇文章中的每一个词，建立以词为单位的倒排文件，检索程序根据检索词在每一篇文章中出现的频率和每一个检索词在一篇文章中出现的概率，对包含这些检索词的文章进行排序，最后输出排序的结果。全文检索技术是搜索引擎的核心支撑技术。</p><p>​    Lucene和搜索引擎不同，Lucene是一套用java或其它语言写的全文检索的工具包，为应用程序提供了很多个api接口去调用，可以简单理解为是一套实现全文检索的类库，搜索引擎是一个全文检索系统，它是一个单独运行的软件系统</p><h2 id="3-Lucene主要包"><a href="#3-Lucene主要包" class="headerlink" title="3.Lucene主要包"></a>3.Lucene主要包</h2><table><thead><tr><th>包名</th><th>功能</th></tr></thead><tbody><tr><td>org.apache.lucene.analysis</td><td>语言分析器，主要用于的切词  Lucene提供的分析器实现类在：  lucene-analyzers-common-4.10.3.jar</td></tr><tr><td>org.apache.lucene.document</td><td>索引存储时的文档结构管理，类似于关系型数据库的表结构</td></tr><tr><td>org.apache.lucene.index</td><td>索引管理，包括索引建立、删除等</td></tr><tr><td>org.apache.lucene.queryParser</td><td>查询分析器，实现查询关键词间的运算，如与、或、非等, 生成查询表达式，</td></tr><tr><td>org.apache.lucene.search</td><td>检索管理，根据查询条件，检索得到结果</td></tr><tr><td>org.apache.lucene.store</td><td>数据存储管理，包括一些I/O操作</td></tr><tr><td>org.apache.lucene.util</td><td>公用类</td></tr></tbody></table><h2 id="4-创建索引和搜索流程"><a href="#4-创建索引和搜索流程" class="headerlink" title="4.创建索引和搜索流程"></a>4.创建索引和搜索流程</h2><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/K8Bm7HFh6B.png?imageslim" alt="mark"></p><p>1、创建索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括：</p><p>​    确定原始内容即要搜索的内容=&gt;获得文档=&gt;创建文档=&gt;分析文档à索引文档</p><p>2、红色表示搜索<a href="">过程</a>，从索引库中搜索内容，搜索过程包括：</p><p>​    用户通过搜索界面=&gt;创建查询=&gt;执行搜索，从索引库搜索=&gt;渲染搜索结果</p><h2 id="5-Solr与Lucene区别"><a href="#5-Solr与Lucene区别" class="headerlink" title="5.Solr与Lucene区别"></a>5.Solr与Lucene区别</h2><p><a href="">Lucene</a>是一个开放源代码的全文检索引擎工具包，它不是一个完整的全文检索应用。Lucene仅提供了完整的查询引擎和索引引擎，目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者以Lucene为基础构建全文检索应用。</p><p> Solr的目标是打造一款企业级的搜索引擎系统，它是基于Lucene一个搜索引擎服务，可以独立运行，通过Solr可以非常快速的构建企业的搜索引擎，通过Solr也可以高效的完成站内搜索功能。</p><h2 id="6-搜索数据方式"><a href="#6-搜索数据方式" class="headerlink" title="6.搜索数据方式"></a>6.搜索数据方式</h2><h3 id="6-1-顺序扫描"><a href="#6-1-顺序扫描" class="headerlink" title="6.1 顺序扫描"></a>6.1 顺序扫描</h3><p>所谓顺序扫描，例如要找内容包含一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。这种方法是顺序扫描方法，数据量大就搜索慢。</p><h3 id="6-2-倒排索引"><a href="#6-2-倒排索引" class="headerlink" title="6.2 倒排索引"></a>6.2 倒排索引</h3><p>倒排索引（也称为倒排文件）是一种存储了来自文本中的映射的索引数据结构。比如单词或者数字，对应到它们在数据库、一个文件或者一组文件中的位置。它是在文档检索系统中使用的最流行的数据结构，在搜索引擎中有大规模使用案例</p><p>例如我们使用新华字典查询汉字，新华字典有偏旁部首的目录（索引），我们查字首先查这个目录，找到这个目录中对应的偏旁部首，就可以通过这个目录中的偏旁部首找到这个字所在的位置（文档）</p><p>倒排索引做两件事情：</p><p>1、提取资源中关键信息， 建立索引 （目录）</p><p>2、搜索时，根据关键字（目录），找到资源的位置</p><p><strong>文档（Document）</strong>：一般搜索引擎处理的对象是互联网网页，对于搜索引擎来讲，Word、PDF、html、XML等不同格式的文件都可以称为文档，一般以文档来表示文本信息。</p><p><strong>文档集合（DocumentCollection）</strong>：由若干文档构成的集合成为文档集合。比如海量的互联网网页等。</p><p><strong>文档编号（Document ID）</strong>：在搜索引擎内部，会为文档集合每个文档赋予一个唯一的内部编号，以作为文档的唯一标识，以便于处理。</p><p><strong>单词编号（Word ID）</strong>：与文档编号类似，搜索引擎内部以唯一的编号来表示某个单词，以作为某个单词的唯一表示。</p><p><strong>倒排索引（Inverted Index）</strong>：倒排索引是实现单词——<strong>文档矩阵</strong>的一种具体存储形式。通过倒排索引，可以根据单次快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：<strong>单词词典和倒排文件</strong>。</p><p><strong>单词词典（Lexicon）</strong>：搜索引擎通常的索引单位是单词，单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引记载单词本身的一些信息及指向倒排列表的指针。单词也就是我们在搜索时的一些关键字，也称为词条。</p><p><strong>倒排列表（PostingList）</strong>：倒排列表记载了出现过某个单词的所有文档的文档列表及单词在该文当中出现的位置信息，每条记录成为一个倒排向（Posting）。根据倒排列表，即可获知哪些文档包含某个单词。</p><p><strong>倒排文件（Inverted File）</strong>：所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件即为倒排文件，倒排文件是存储倒排索引的物理文件。</p><h2 id="7-倒排索引"><a href="#7-倒排索引" class="headerlink" title="7.  倒排索引"></a>7.  倒排索引</h2><h3 id="7-1单词-文档矩阵的基本模型："><a href="#7-1单词-文档矩阵的基本模型：" class="headerlink" title="7.1单词-文档矩阵的基本模型："></a>7.1单词-文档矩阵的基本模型：</h3><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/Ch5G2E7DHE.png?imageslim" alt="mark"></p><p>该矩阵模型代表的含义：</p><p>词1在文档1、文档4中出现，文档1包含了词1和词4。</p><p>词2在文档2、文档5中出现，文档2包含词2。</p><h3 id="7-2-创建倒排索引过程"><a href="#7-2-创建倒排索引过程" class="headerlink" title="7.2 创建倒排索引过程"></a>7.2 创建倒排索引过程</h3><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/2HAJd0GK6d.png?imageslim" alt="mark"></p><h3 id="7-3-基本倒排索引结构"><a href="#7-3-基本倒排索引结构" class="headerlink" title="7.3 基本倒排索引结构"></a>7.3 基本倒排索引结构</h3><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/964676fHlF.png?imageslim" alt="mark"></p><p>第1列单词ID即为每个单词的编号。 </p><p>第2列即为对应的单词。 </p><p>第3列即为每个单词对应的倒排序表。（比如单词“拉斯”，单词编号为8，倒排序表为｛3，5｝，说明文档集合中文档3和文档5包含这个单词。）</p><h3 id="7-4-复杂倒排索引结构"><a href="#7-4-复杂倒排索引结构" class="headerlink" title="7.4  复杂倒排索引结构"></a>7.4  复杂倒排索引结构</h3><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/CGid1D84i7.png?imageslim" alt="mark"></p><p>就编号8—拉斯—｛（3：1）；（5，1）｝来说，（3，1）表示“拉斯”在文档3中出现一次，（5，1）表示“拉斯”在文档5中出现1次。</p><h3 id="7-5-完整倒排索引结构"><a href="#7-5-完整倒排索引结构" class="headerlink" title="7.5 完整倒排索引结构"></a>7.5 完整倒排索引结构</h3><p><img src="http://ozaomob5f.bkt.clouddn.com/images/171224/368g0ciF2g.png?imageslim" alt="mark"></p><p>就编号8—拉斯—2—｛（3;1;<4>），（5;1;<4>）｝来说，文档频率2表示在两个文档出现。“<4>”表示单词出现的位置是文档中的第4个单词。 </4></4></4></p><p>这个倒排索引基本上是一个完备的索引系统了，实际搜索系统的索引结构基本如此。</p><h2 id="8-单词词典"><a href="#8-单词词典" class="headerlink" title="8. 单词词典"></a>8. 单词词典</h2><p>单词词典是倒排索引中非常重要的组成部分，它用来维护文档集合中出现过的所有单词的相关信息，同时用来记载某个单词对应的倒排列表在倒排文件中的位置信息。在支持搜索时，根据用户的查询词，去单词词典里查询，就能够获得相应的倒排列表，并以此作为后续排序的基础。<br>​       对于一个规模很大的文档集合来说，可能包含几十万甚至上百万的不同单词，能否快速定位某个单词，这直接影响搜索时的响应速度，所以需要高效的数据结构来对单词词典进行构建和查找，常用的数据结构包括哈希加链表结构和树形词典结构。</p><p>4.1   哈希加链表</p><p>​       图1-7是这种词典结构的示意图。这种词典结构主要由两个部分构成：</p><p>​        主体部分是哈希表，每个哈希表项保存一个指针，指针指向冲突链表，在冲突链表里，相同哈希值的单词形成链表结构。之所以会有冲突链表，是因为两个不同单词获得相同的哈希值，如果是这样，在哈希方法里被称做是一次冲突，可以将相同哈希值的单词存储在链表里，以供后续查找。<br>​                       <img src="http://img.my.csdn.net/uploads/201209/10/1347269599_3828.jpg" alt="img"></p><p>​                        图1-7  哈希加链表词典结构</p><p>​       在建立索引的过程中，词典结构也会相应地被构建出来。比如在解析一个新文档的时候，对于某个在文档中出现的单词T，首先利用哈希函数获得其哈希值，之后根据哈希值对应的哈希表项读取其中保存的指针，就找到了对应的冲突链表。如果冲突链表里已经存在这个单词，说明单词在之前解析的文档里已经出现过。如果在冲突链表里没有发现这个单词，说明该单词是首次碰到，则将其加入冲突链表里。通过这种方式，当文档集合内所有文档解析完毕时，相应的词典结构也就建立起来了。</p><p>​        在响应用户查询请求时，其过程与建立词典类似，不同点在于即使词典里没出现过某个单词，也不会添加到词典内。以图1-7为例，假设用户输入的查询请求为单词3，对这个单词进行哈希，定位到哈希表内的2号槽，从其保留的指针可以获得冲突链表，依次将单词3和冲突链表内的单词比较，发现单词3在冲突链表内，于是找到这个单词，之后可以读出这个单词对应的倒排列表来进行后续的工作，如果没有找到这个单词，说明文档集合内没有任何文档包含单词，则搜索结果为空。</p><p><strong>4.2   树形结构</strong><br>​       B树（或者B+树）是另外一种高效查找结构，图1-8是一个 B树结构示意图。B树与哈希方式查找不同，需要字典项能够按照大小排序（数字或者字符序），而哈希方式则无须数据满足此项要求。<br>​       B树形成了层级查找结构，中间节点用于指出一定顺序范围的词典项目存储在哪个子树中，起到根据词典项比较大小进行导航的作用，最底层的叶子节点存储单词的地址信息，根据这个地址就可以提取出单词字符串。<br>​                  <img src="http://img.my.csdn.net/uploads/201209/10/1347269740_2402.jpg" alt="img"><br>​                                           图1-8  B树查找结构 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lucene-amp-solr&quot;&gt;&lt;a href=&quot;#Lucene-amp-solr&quot; class=&quot;headerlink&quot; title=&quot;Lucene&amp;amp;solr&quot;&gt;&lt;/a&gt;Lucene&amp;amp;solr&lt;/h1&gt;&lt;h2 id=&quot;1-Lucene简介&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="solr" scheme="http://www.top.com/tags/solr/"/>
    
      <category term="倒排索引" scheme="http://www.top.com/tags/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    
      <category term="Lucene" scheme="http://www.top.com/tags/Lucene/"/>
    
  </entry>
  
  <entry>
    <title>Redis的五种数据类型</title>
    <link href="http://www.top.com/2017/12/15/Redis%E7%9A%84%E4%BA%94%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.top.com/2017/12/15/Redis的五中数据类型/</id>
    <published>2017-12-15T03:27:08.000Z</published>
    <updated>2017-12-19T03:28:27.979Z</updated>
    
    <content type="html"><![CDATA[<p>常用数据类型简介：</p><h2 id="一-redis常用五种数据类型-string-hash-list-set-zset-sorted-set"><a href="#一-redis常用五种数据类型-string-hash-list-set-zset-sorted-set" class="headerlink" title="一,redis常用五种数据类型:string,hash,list,set,zset(sorted set)."></a>一,redis常用五种数据类型:string,hash,list,set,zset(sorted set).</h2><h3 id="1-String类型"><a href="#1-String类型" class="headerlink" title="1.String类型"></a>1.String类型</h3><p>String是最简单的类型，一个key对应一个value</p><p>String类型的数据最大1G。<br>String类型的值可以被视作integer，从而可以让“INCR”命令族操作(incrby、decr、decrby),这种情况下，该integer的值限制在64位有符号数。<br>在list、set和zset中包含的独立的元素类型都是Redis String类型。</p><h3 id="2-List类型"><a href="#2-List类型" class="headerlink" title="2.List类型"></a>2.List类型</h3><p>链表类型，主要功能是push、pop、获取一个范围的所有值等。其中的key可以理解为链表的名字。</p><p>在Redis中，list就是Redis String的列表，按照插入顺序排序。比如使用LPUSH命令在list头插入一个元素，使用RPUSH命令在list的尾插入一个元素。当这两个命令之一作用于一个空的key时，一个新的list就创建出来了。</p><p>List的最大长度是2^32-1个元素。</p><h3 id="3-Set类型"><a href="#3-Set类型" class="headerlink" title="3.Set类型"></a>3.Set类型</h3><p>集合，和数学中的集合概念相似。操作中的key理解为集合的名字。</p><p>在Redis中，set就是Redis String的无序集合，不允许有重复元素。</p><p>Set的最大元素数是2^32-1。</p><p>Redis中对set的操作还有交集、并集、差集等。</p><h3 id="4-ZSet-Sorted-Set-类型"><a href="#4-ZSet-Sorted-Set-类型" class="headerlink" title="4.ZSet(Sorted Set)类型"></a>4.ZSet(Sorted Set)类型</h3><p>Zset是set的一个升级版本，在set的基础上增加了一个顺序属性，这一属性在添加修改元素时可以指定，每次指定后zset会自动安装指定值重新调整顺序。可以理解为一张表，一列存value，一列存顺序。操作中的key理解为zset的名字。</p><p>Zset的最大元素数是2^32-1。</p><p>对于已经有序的zset，仍然可以使用SORT命令，通过指定ASC|DESC参数对其进行排序。</p><h3 id="5-hash类型"><a href="#5-hash类型" class="headerlink" title="5.hash类型"></a>5.hash类型</h3><p>hash是最接近关系数据库结构的数据类型，可以将数据库一条记录或程序中一个对象转换成hashmap存放在redis中。</p><h2 id="二、jedis操作命令："><a href="#二、jedis操作命令：" class="headerlink" title="二、jedis操作命令："></a>二、jedis操作命令：</h2><h3 id="1-对value操作的命令"><a href="#1-对value操作的命令" class="headerlink" title="1.对value操作的命令"></a>1.对value操作的命令</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> exists(<span class="built_in">key</span>)：确认一个<span class="built_in">key</span>是否存在</span><br><span class="line"></span><br><span class="line"> del(<span class="built_in">key</span>)：删除一个<span class="built_in">key</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">type</span>(<span class="built_in">key</span>)：返回值的类型</span><br><span class="line"></span><br><span class="line"> <span class="built_in">keys</span>(pattern)：返回满足给定pattern的所有<span class="built_in">key</span></span><br><span class="line"></span><br><span class="line"> randomkey：随机返回<span class="built_in">key</span>空间的一个<span class="built_in">key</span></span><br><span class="line"></span><br><span class="line"> rename(oldname, newname)：将<span class="built_in">key</span>由oldname重命名为newname，若newname存在则删除newname表示的<span class="built_in">key</span></span><br><span class="line"></span><br><span class="line"> dbsize：返回当前数据库中<span class="built_in">key</span>的数目</span><br><span class="line"></span><br><span class="line"> expire：设定一个<span class="built_in">key</span>的活动时间（s）</span><br><span class="line"></span><br><span class="line"> ttl：获得一个<span class="built_in">key</span>的活动时间</span><br><span class="line"></span><br><span class="line"> <span class="keyword">select</span>(index)：按索引查询</span><br><span class="line"></span><br><span class="line"> move(<span class="built_in">key</span>, dbindex)：将当前数据库中的<span class="built_in">key</span>转移到有dbindex索引的数据库</span><br><span class="line"></span><br><span class="line"> flushdb：删除当前选择数据库中的所有<span class="built_in">key</span></span><br><span class="line"></span><br><span class="line"> flushall：删除所有数据库中的所有<span class="built_in">key</span></span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure><h3 id="2-对String操作的命令"><a href="#2-对String操作的命令" class="headerlink" title="2.对String操作的命令"></a>2.对String操作的命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">set</span>(<span class="keyword">key</span>, <span class="keyword">value</span>)：给数据库中名称为<span class="keyword">key</span>的<span class="keyword">string</span>赋予值<span class="keyword">value</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">get</span>(<span class="keyword">key</span>)：返回数据库中名称为<span class="keyword">key</span>的<span class="keyword">string</span>的<span class="keyword">value</span></span><br><span class="line"></span><br><span class="line"> getset(<span class="keyword">key</span>, <span class="keyword">value</span>)：给名称为<span class="keyword">key</span>的<span class="keyword">string</span>赋予上一次的<span class="keyword">value</span></span><br><span class="line"></span><br><span class="line"> mget(key1, key2,…, <span class="keyword">key</span> N)：返回库中多个<span class="keyword">string</span>（它们的名称为key1，key2…）的<span class="keyword">value</span>     s</span><br><span class="line"></span><br><span class="line"> setnx(<span class="keyword">key</span>, <span class="keyword">value</span>)：如果不存在名称为<span class="keyword">key</span>的<span class="keyword">string</span>，则向库中添加<span class="keyword">string</span>，名称为<span class="keyword">key</span>，值为<span class="keyword">value</span></span><br><span class="line"></span><br><span class="line"> setex(<span class="keyword">key</span>, <span class="keyword">time</span>, <span class="keyword">value</span>)：向库中添加<span class="keyword">string</span>（名称为<span class="keyword">key</span>，值为<span class="keyword">value</span>）同时，设定过期时间<span class="keyword">time</span></span><br><span class="line"></span><br><span class="line"> mset(key1, value1, key2, value2,…<span class="keyword">key</span> N, <span class="keyword">value</span> N)：同时给多个<span class="keyword">string</span>赋值，名称为<span class="keyword">key</span> i的<span class="keyword">string</span>赋值<span class="keyword">value</span> i</span><br><span class="line"></span><br><span class="line"> msetnx(key1, value1, key2, value2,…<span class="keyword">key</span> N, <span class="keyword">value</span> N)：如果所有名称为<span class="keyword">key</span> i的<span class="keyword">string</span>都不存在，则向库中添加<span class="keyword">string</span>，名称           <span class="keyword">key</span> i赋值为<span class="keyword">value</span> i</span><br><span class="line"></span><br><span class="line"> incr(<span class="keyword">key</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>增<span class="number">1</span>操作</span><br><span class="line"></span><br><span class="line"> incrby(<span class="keyword">key</span>, <span class="built_in">integer</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>增加<span class="built_in">integer</span></span><br><span class="line"></span><br><span class="line"> decr(<span class="keyword">key</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>减<span class="number">1</span>操作</span><br><span class="line"></span><br><span class="line"> decrby(<span class="keyword">key</span>, <span class="built_in">integer</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>减少<span class="built_in">integer</span></span><br><span class="line"></span><br><span class="line"> append(<span class="keyword">key</span>, <span class="keyword">value</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>的值附加<span class="keyword">value</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">substr</span>(<span class="keyword">key</span>, <span class="keyword">start</span>, <span class="keyword">end</span>)：返回名称为<span class="keyword">key</span>的<span class="keyword">string</span>的<span class="keyword">value</span>的子串</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure><h3 id="3-对List操作的命令"><a href="#3-对List操作的命令" class="headerlink" title="3.对List操作的命令"></a>3.对List操作的命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> rpush(key, value)：在名称为key的list尾添加一个值为value的元素  </span><br><span class="line"></span><br><span class="line"> lpush(key, value)：在名称为key的list头添加一个值为value的 元素</span><br><span class="line"></span><br><span class="line"> llen(key)：返回名称为key的list的长度</span><br><span class="line"></span><br><span class="line"> lrange(key, <span class="keyword">start</span>, <span class="keyword">end</span>)：返回名称为<span class="keyword">key</span>的<span class="keyword">list</span>中<span class="keyword">start</span>至<span class="keyword">end</span>之间的元素（下标从<span class="number">0</span>开始，下同）</span><br><span class="line"></span><br><span class="line"> <span class="keyword">ltrim</span>(<span class="keyword">key</span>, <span class="keyword">start</span>, <span class="keyword">end</span>)：截取名称为<span class="keyword">key</span>的<span class="keyword">list</span>，保留<span class="keyword">start</span>至<span class="keyword">end</span>之间的元素</span><br><span class="line"></span><br><span class="line"> lindex(<span class="keyword">key</span>, <span class="keyword">index</span>)：返回名称为<span class="keyword">key</span>的<span class="keyword">list</span>中<span class="keyword">index</span>位置的元素</span><br><span class="line"></span><br><span class="line"> lset(<span class="keyword">key</span>, <span class="keyword">index</span>, <span class="keyword">value</span>)：给名称为<span class="keyword">key</span>的<span class="keyword">list</span>中<span class="keyword">index</span>位置的元素赋值为<span class="keyword">value</span></span><br><span class="line"></span><br><span class="line"> lrem(<span class="keyword">key</span>, <span class="keyword">count</span>, <span class="keyword">value</span>)：删除<span class="keyword">count</span>个名称为<span class="keyword">key</span>的<span class="keyword">list</span>中值为<span class="keyword">value</span>的元素。<span class="keyword">count</span>为<span class="number">0</span>，删除所有值为<span class="keyword">value</span>的元素，<span class="keyword">count</span>&gt;<span class="number">0</span>      从头至尾删除<span class="keyword">count</span>个值为<span class="keyword">value</span>的元素，<span class="keyword">count</span>&lt;<span class="number">0</span>从尾到头删除|<span class="keyword">count</span>|个值为<span class="keyword">value</span>的元素。</span><br><span class="line"></span><br><span class="line"> lpop(<span class="keyword">key</span>)：返回并删除名称为<span class="keyword">key</span>的<span class="keyword">list</span>中的首元素</span><br><span class="line"></span><br><span class="line"> rpop(<span class="keyword">key</span>)：返回并删除名称为<span class="keyword">key</span>的<span class="keyword">list</span>中的尾元素</span><br><span class="line"></span><br><span class="line"> blpop(key1, key2,… <span class="keyword">key</span> N, <span class="keyword">timeout</span>)：lpop 命令的<span class="keyword">block</span>版本。即当<span class="keyword">timeout</span>为<span class="number">0</span>时，若遇到名称为<span class="keyword">key</span> i的<span class="keyword">list</span>不存在或该<span class="keyword">list</span>为空，则命令结束。如果 <span class="keyword">timeout</span>&gt;<span class="number">0</span>，则遇到上述情况时，等待<span class="keyword">timeout</span>秒，如果问题没有解决，则对<span class="keyword">key</span> i+<span class="number">1</span>开始的<span class="keyword">list</span>执行pop操作。</span><br><span class="line"></span><br><span class="line"> brpop(key1, key2,… <span class="keyword">key</span> N, <span class="keyword">timeout</span>)：rpop的<span class="keyword">block</span>版本。参考上一命令。</span><br><span class="line"></span><br><span class="line"> rpoplpush(srckey, dstkey)：返回并删除名称为srckey的<span class="keyword">list</span>的尾元素，并将该元素添加到名称为dstkey的<span class="keyword">list</span>的头部</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure><h3 id="4-对Set操作的命令"><a href="#4-对Set操作的命令" class="headerlink" title="4.对Set操作的命令"></a>4.对Set操作的命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> sadd(key, member)：向名称为key的<span class="keyword">set</span>中添加元素<span class="keyword">member</span></span><br><span class="line"></span><br><span class="line"> srem(<span class="keyword">key</span>, <span class="keyword">member</span>) ：删除名称为<span class="keyword">key</span>的<span class="keyword">set</span>中的元素<span class="keyword">member</span></span><br><span class="line"></span><br><span class="line"> spop(<span class="keyword">key</span>) ：随机返回并删除名称为<span class="keyword">key</span>的<span class="keyword">set</span>中一个元素  </span><br><span class="line"></span><br><span class="line"> smove(srckey, dstkey, <span class="keyword">member</span>) ：将<span class="keyword">member</span>元素从名称为srckey的集合移到名称为dstkey的集合</span><br><span class="line"></span><br><span class="line"> scard(<span class="keyword">key</span>) ：返回名称为<span class="keyword">key</span>的<span class="keyword">set</span>的基数        </span><br><span class="line"></span><br><span class="line"> sismember(<span class="keyword">key</span>, <span class="keyword">member</span>) ：测试<span class="keyword">member</span>是否是名称为<span class="keyword">key</span>的<span class="keyword">set</span>的元素</span><br><span class="line"></span><br><span class="line"> sinter(key1, key2,…<span class="keyword">key</span> N) ：求交集</span><br><span class="line"></span><br><span class="line"> sinterstore(dstkey, key1, key2,…<span class="keyword">key</span> N) ：求交集并将交集保存到dstkey的集合</span><br><span class="line"></span><br><span class="line"> sunion(key1, key2,…<span class="keyword">key</span> N) ：求并集</span><br><span class="line"></span><br><span class="line"> sunionstore(dstkey, key1, key2,…<span class="keyword">key</span> N) ：求并集并将并集保存到dstkey的集合</span><br><span class="line"></span><br><span class="line"> sdiff(key1, key2,…<span class="keyword">key</span> N) ：求差集</span><br><span class="line"></span><br><span class="line"> sdiffstore(dstkey, key1, key2,…<span class="keyword">key</span> N) ：求差集并将差集保存到dstkey的集合</span><br><span class="line"></span><br><span class="line"> smembers(<span class="keyword">key</span>) ：返回名称为<span class="keyword">key</span>的<span class="keyword">set</span>的所有元素</span><br><span class="line"></span><br><span class="line"> srandmember(<span class="keyword">key</span>) ：随机返回名称为<span class="keyword">key</span>的<span class="keyword">set</span>的一个元素</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure><h3 id="5-对zset（sorted-set）操作的命令"><a href="#5-对zset（sorted-set）操作的命令" class="headerlink" title="5.对zset（sorted set）操作的命令"></a>5.对zset（sorted set）操作的命令</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> zadd(<span class="built_in">key</span>, score, <span class="built_in">member</span>)：向名称为<span class="built_in">key</span>的zset中添加元素<span class="built_in">member</span>，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。</span><br><span class="line"></span><br><span class="line"> zrem(<span class="built_in">key</span>, <span class="built_in">member</span>) ：删除名称为<span class="built_in">key</span>的zset中的元素<span class="built_in">member</span></span><br><span class="line"></span><br><span class="line"> zincrby(<span class="built_in">key</span>, increment, <span class="built_in">member</span>) ：如果在名称为<span class="built_in">key</span>的zset中已经存在元素<span class="built_in">member</span>，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment</span><br><span class="line"></span><br><span class="line"> zrank(<span class="built_in">key</span>, <span class="built_in">member</span>) ：返回名称为<span class="built_in">key</span>的zset（元素已按score从小到大排序）中<span class="built_in">member</span>元素的<span class="built_in">rank</span>（即index，从<span class="number">0</span>开始），若没有<span class="built_in">member</span>元素，返回“nil”</span><br><span class="line"></span><br><span class="line"> zrevrank(<span class="built_in">key</span>, <span class="built_in">member</span>) ：返回名称为<span class="built_in">key</span>的zset（元素已按score从大到小排序）中<span class="built_in">member</span>元素的<span class="built_in">rank</span>（即index，从<span class="number">0</span>开始），若没有<span class="built_in">member</span>元素，返回“nil”</span><br><span class="line"></span><br><span class="line"> zrange(<span class="built_in">key</span>, start, end)：返回名称为<span class="built_in">key</span>的zset（元素已按score从小到大排序）中的index从start到end的所有元素</span><br><span class="line"></span><br><span class="line"> zrevrange(<span class="built_in">key</span>, start, end)：返回名称为<span class="built_in">key</span>的zset（元素已按score从大到小排序）中的index从start到end的所有元素</span><br><span class="line"></span><br><span class="line"> zrangebyscore(<span class="built_in">key</span>, <span class="built_in">min</span>, <span class="built_in">max</span>)：返回名称为<span class="built_in">key</span>的zset中score &gt;= <span class="built_in">min</span>且score &lt;= <span class="built_in">max</span>的所有元素</span><br><span class="line"></span><br><span class="line"> zcard(<span class="built_in">key</span>)：返回名称为<span class="built_in">key</span>的zset的基数</span><br><span class="line"></span><br><span class="line"> zscore(<span class="built_in">key</span>, element)：返回名称为<span class="built_in">key</span>的zset中元素element的score</span><br><span class="line"></span><br><span class="line"> zremrangebyrank(<span class="built_in">key</span>, <span class="built_in">min</span>, <span class="built_in">max</span>)：删除名称为<span class="built_in">key</span>的zset中<span class="built_in">rank</span> &gt;= <span class="built_in">min</span>且<span class="built_in">rank</span> &lt;= <span class="built_in">max</span>的所有元素</span><br><span class="line"></span><br><span class="line"> zremrangebyscore(<span class="built_in">key</span>, <span class="built_in">min</span>, <span class="built_in">max</span>) ：删除名称为<span class="built_in">key</span>的zset中score &gt;= <span class="built_in">min</span>且score &lt;= <span class="built_in">max</span>的所有元素</span><br><span class="line"></span><br><span class="line"> zunionstore / zinterstore(dstkeyN, key1,…,keyN, WEIGHTS w1,…wN, AGGREGATE SUM|MIN|MAX)：对N个zset求并集和交集，并将最后的集合保存在dstkeyN中。对于集合中每一个元素的score，在进行AGGREGATE运算前，都要乘以对于的WEIGHT参数。如果没有提供WEIGHT，默认为<span class="number">1</span>。默认的AGGREGATE是SUM，即结果集合中元素的score是所有集合对应元素进行 SUM运算的值，而MIN和MAX是指，结果集合中元素的score是所有集合对应元素中最小值和最大值。</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure><h3 id="6-对Hash操作的命令"><a href="#6-对Hash操作的命令" class="headerlink" title="6.对Hash操作的命令"></a>6.对Hash操作的命令</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> hset(<span class="built_in">key</span>, field, <span class="built_in">value</span>)：向名称为<span class="built_in">key</span>的hash中添加元素field&lt;—&gt;<span class="built_in">value</span></span><br><span class="line"></span><br><span class="line"> hget(<span class="built_in">key</span>, field)：返回名称为<span class="built_in">key</span>的hash中field对应的<span class="built_in">value</span></span><br><span class="line"></span><br><span class="line"> hmget(<span class="built_in">key</span>, field1, …,field N)：返回名称为<span class="built_in">key</span>的hash中field i对应的<span class="built_in">value</span></span><br><span class="line"></span><br><span class="line"> hmset(<span class="built_in">key</span>, field1, value1,…,field N, <span class="built_in">value</span> N)：向名称为<span class="built_in">key</span>的hash中添加元素field i&lt;—&gt;<span class="built_in">value</span> i</span><br><span class="line"></span><br><span class="line"> hincrby(<span class="built_in">key</span>, field, integer)：将名称为<span class="built_in">key</span>的hash中field的<span class="built_in">value</span>增加integer</span><br><span class="line"></span><br><span class="line"> hexists(<span class="built_in">key</span>, field)：名称为<span class="built_in">key</span>的hash中是否存在键为field的域</span><br><span class="line"></span><br><span class="line"> <span class="built_in">hdel</span>(<span class="built_in">key</span>, field)：删除名称为<span class="built_in">key</span>的hash中键为field的域</span><br><span class="line"></span><br><span class="line"> hlen(<span class="built_in">key</span>)：返回名称为<span class="built_in">key</span>的hash中元素个数</span><br><span class="line"></span><br><span class="line"> hkeys(<span class="built_in">key</span>)：返回名称为<span class="built_in">key</span>的hash中所有键</span><br><span class="line"></span><br><span class="line"> hvals(<span class="built_in">key</span>)：返回名称为<span class="built_in">key</span>的hash中所有键对应的<span class="built_in">value</span></span><br><span class="line"></span><br><span class="line"> hgetall(<span class="built_in">key</span>)：返回名称为<span class="built_in">key</span>的hash中所有的键（field）及其对应的<span class="built_in">value</span></span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure><h2 id="三、各种数据类型所对应的应用场景"><a href="#三、各种数据类型所对应的应用场景" class="headerlink" title="三、各种数据类型所对应的应用场景"></a>三、各种数据类型所对应的应用场景</h2><h3 id="1-String类型的应用场景"><a href="#1-String类型的应用场景" class="headerlink" title="1.String类型的应用场景"></a>1.String类型的应用场景</h3><p>String是最常用的一种数据类型,普通的key/value存储.</p><h3 id="2-list类型的应用场景"><a href="#2-list类型的应用场景" class="headerlink" title="2.list类型的应用场景"></a>2.list类型的应用场景</h3><p>比较适用于列表式存储且顺序相对比较固定，例如：</p><p>省份、城市列表</p><p>品牌、厂商、车系、车型等列表</p><p>拆车坊专题列表…</p><h3 id="3-set类型的应用场景"><a href="#3-set类型的应用场景" class="headerlink" title="3.set类型的应用场景"></a>3.set类型的应用场景</h3><p>Set对外提供的功能与list类似,当需要存储一个列表数据,又不希望出现重复数据时,可选用set</p><h3 id="4-zset-sorted-set-类型的应用场景"><a href="#4-zset-sorted-set-类型的应用场景" class="headerlink" title="4.zset(sorted set)类型的应用场景"></a>4.zset(sorted set)类型的应用场景</h3><p>zset的使用场景与set类似,区别是set不是自动有序的,而zset可以通过用户额外提供一个优先级(score)的参数来为成员排序,并且是插入有序的,即自动排序.当你需要一个有序的并且不重复的集合列表,那么可以选择zset数据结构。例如:</p><p>根据PV排序的热门车系车型列表</p><p>根据时间排序的新闻列表</p><h3 id="5-hash类型的应用场景"><a href="#5-hash类型的应用场景" class="headerlink" title="5.hash类型的应用场景"></a>5.hash类型的应用场景</h3><p>类似于表记录的存储</p><p>页面视图所需数据的存储</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常用数据类型简介：&lt;/p&gt;
&lt;h2 id=&quot;一-redis常用五种数据类型-string-hash-list-set-zset-sorted-set&quot;&gt;&lt;a href=&quot;#一-redis常用五种数据类型-string-hash-list-set-zset-sorted-se
      
    
    </summary>
    
    
      <category term="redis" scheme="http://www.top.com/tags/redis/"/>
    
      <category term="nosql" scheme="http://www.top.com/tags/nosql/"/>
    
  </entry>
  
  <entry>
    <title>mysql学习</title>
    <link href="http://www.top.com/2017/11/28/mysql03/"/>
    <id>http://www.top.com/2017/11/28/mysql03/</id>
    <published>2017-11-28T06:23:50.000Z</published>
    <updated>2017-12-01T17:28:28.030Z</updated>
    
    <content type="html"><![CDATA[<h4 id="01-多表查询-交叉查询【了解】"><a href="#01-多表查询-交叉查询【了解】" class="headerlink" title="01.多表查询_交叉查询【了解】"></a>01.多表查询_交叉查询【了解】</h4><pre><code>1.查询结果=左表的总记录数 * 右表的总记录数 -- 笛卡尔积</code></pre><h4 id="02-多表查询-内连接查询【重点掌握】"><a href="#02-多表查询-内连接查询【重点掌握】" class="headerlink" title="02.多表查询_内连接查询【重点掌握】"></a>02.多表查询_内连接查询【重点掌握】</h4><pre><code>1.隐式内连接【常用】：    1).格式：select 字段列表 from 表1,表2 where 表1和表2的等值关系;    2).例如：查询商品信息，要显示所对应类别信息        select * from products , category where products.category_id = catetory.cid;        只保留两个表的部分字段，使用表别名：        SELECT p.pname,p.price,c.cname FROM products p , category c WHERE p.category_id = c.cid;    3).练习：查询&quot;市&quot;的所有信息，并且显示对应的&quot;省名&quot;        SELECT c.cname AS &apos;市&apos;,p.pname AS &apos;省&apos; FROM city c,province p WHERE c.pid = p.pid;2.显示内连接：    1).格式：select 字段列表 from 表1 INNER JOIN 表2 ON 等值关系；    2).例如：查询商品信息，要显示所对应类别信息        select * from products p inner join category c on p.category_id = c.cid;    3).练习：查询&quot;市&quot;的所有信息，并且显示对应的&quot;省名&quot;        SELECT c.cname AS &apos;市&apos;,p.pname AS &apos;省&apos; from city c inner join province p on c.pid = p.pid;注意：1.内连接的查询结果：两个表中的等值记录；2.两种内连接都可以再添加其它where条件：    隐式内连接：select .. from 表1,表2 where 等值条件 and 其它条件...    显示内连接：select .. from 表1 inner join 表2 on 等值条件 where 其它条件....3.两种查询的格式说明：    隐式内连接：select .. from 表1,表2 on 等值条件//错误    显示内连接：select .. from 表1 inner join 表2 where 等值条件//OK的</code></pre><h4 id="03-多表查询-外连接查询【重点掌握】"><a href="#03-多表查询-外连接查询【重点掌握】" class="headerlink" title="03.多表查询_外连接查询【重点掌握】"></a>03.多表查询_外连接查询【重点掌握】</h4><pre><code>1.左外连接查询：    1).格式：select 字段列表 from 表1 left join 表2 on 等值关系;    2).查询结果：左表的所有记录，和右表的等值记录;    3).例如：需求：查询出所有商品(包括没有类别的商品)，有类别的商品要显示类别名称。        SELECT * FROM products p LEFT JOIN category c ON p.category_id = c.cid;2.右外连接查询：    1).格式：select 字段列表 from 表1 right join 表2 on 等值关系；    2).查询结果：右表的所有记录，和左表中的等值记录；    3).例如：需求：查询出所有的商品类别，如果类别下有商品的，要同时显示商品信息；        SELECT * FROM products p RIGHT JOIN category c ON p.category_id = c.cid;</code></pre><h4 id="04-子查询【重点掌握】"><a href="#04-子查询【重点掌握】" class="headerlink" title="04.子查询【重点掌握】"></a>04.子查询【重点掌握】</h4><pre><code>1.在一个查询内部，可以再写一个查询，这个写在内部的查询就叫：子查询；2.子查询的结果可以作为另一个查询：判断条件，表使用。3.例子：查询价格高于&quot;劲霸&quot;的商品信息；    SELECT * FROM products WHERE price &gt; (SELECT price FROM products WHERE pname = &apos;劲霸&apos;);4.练习：    1).查询化妆品类别的商品信息       a).使用多表连接查询：        select * from products p , category c where p.category_id = c.cid and c.cname = &apos;化妆品&apos;;       b).使用子查询(单表查询)        SELECT * FROM products WHERE category_id = (SELECT cid FROM category WHERE cname = &apos;化妆品&apos;);       c).使用子查询作为第三张表：select * from (子查询)        SELECT * FROM products p ,(SELECT * FROM category WHERE cname = &apos;化妆品&apos;) c WHERE p.category_id = c.cid;    2).查询所有&quot;家电&quot;,&quot;服饰&quot;类商品的信息：        select * from products where category_id = 1 or category_id = 2;        改进：        select * from products where category_id in (1,2);        改进：        select * from products where category_id in (select cid from category where cname in (&apos;家电&apos;,&apos;服饰&apos;));</code></pre><h4 id="学习目标总结："><a href="#学习目标总结：" class="headerlink" title="学习目标总结："></a>学习目标总结：</h4><p>1，能够使用内连接进行多表查询<br>a，    说出内连接的两种查询方式</p><pre><code>1.隐式内连接2.显示内连接</code></pre><p>b，    写出显式内连接的SQL语句<br>        select <em> from products p inner join category c on p.category_id = c.cid;<br>c，    写出隐式内连接的SQL语句<br>        select </em> from products p , category c where p.category_id = c.cid;<br>2，能够使用外连接进行多表查询<br>a，    说出外连接的两种查询方式<br>        1.左外查询<br>        2.右外查询<br>b，    写出左外连接的SQL语句<br>        select <em> from products p left join category c on p.category_id = c.cid;//所有左表中的记录，和右表的等值记录<br>c，    写出右外连接的SQL语句<br>        select </em> from products p right join category c on p.category_id = c.cid;//所有右表中的记录，和左表的等值记录<br>3，能够使用子查询进行多表查询<br>    select * from products where category_id in (select cid from category where cname in (‘家电’,’服饰’));</p><p>扩展：三表联查：<br>    1.隐式内连接：使用user表，role表，user_role表进行测试<br>        select <em> from users u , role r,user_role ur where u.uid = ur.uid and ur.rid = r.rid;<br>    2.显示内连接：<br>        select </em> from users u inner join user_role ur on u.uid = ur.uid inner join role r on ur.rid = r.rid;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;01-多表查询-交叉查询【了解】&quot;&gt;&lt;a href=&quot;#01-多表查询-交叉查询【了解】&quot; class=&quot;headerlink&quot; title=&quot;01.多表查询_交叉查询【了解】&quot;&gt;&lt;/a&gt;01.多表查询_交叉查询【了解】&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1.查询结果
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.top.com/tags/mysql/"/>
    
      <category term="sql" scheme="http://www.top.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>mysql学习</title>
    <link href="http://www.top.com/2017/11/27/mysql02/"/>
    <id>http://www.top.com/2017/11/27/mysql02/</id>
    <published>2017-11-27T06:23:50.000Z</published>
    <updated>2017-12-01T17:27:59.344Z</updated>
    
    <content type="html"><![CDATA[<h4 id="01-SQL高级查询-排序："><a href="#01-SQL高级查询-排序：" class="headerlink" title="01.SQL高级查询_排序："></a>01.SQL高级查询_排序：</h4><pre><code>1.使用的关键字：order by 字段名 ASC(升序--默认) / DESC(降序)  例如：查询所有商品，要求结果按价格从小到大排序    SELECT * FROM product ORDER BY proDate ASC;2.注意：升序可以不写asc关键字，例如：    select * from product order by proData;//升序3.排序：    升序(ASC):从小到大；    降序(DESC):从大到小；4.对多列进行排序：  例如：对多列进行排序：按金额排序，如果金额相同，按生产日期升序排序    SELECT * FROM product ORDER BY price ASC,proDate ASC;    先按第一个字段排序，在第一个字段值相同的情况下，再按第二个字段排。5.如果有查询条件，写法：    select * from 表名 where 条件  order by 字段 ... ;</code></pre><h4 id="02-SQL高级查询-聚合函数："><a href="#02-SQL高级查询-聚合函数：" class="headerlink" title="02.SQL高级查询_聚合函数："></a>02.SQL高级查询_聚合函数：</h4><pre><code>1.我经常会有需求，对某列进行汇总，这就需要使用&quot;聚合函数&quot;；2.今天我们掌握的五个聚合函数：    a).count(*/字段名)：统计指定列不为NULL的记录行数--任何数据类型        例如：查询电脑类别的商品，共有多少种        SELECT COUNT(*) FROM product WHERE categoryName = &apos;电脑&apos;;    b).sum(列名)：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0--数值类型的列        例如：查询电脑类商品的价格总数是多少？        select sum(price) from product where categoryName = &apos;电脑&apos;;    c).max(列名)：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算--数值类型、日期类型        例如：查询电脑类商品的最高价格？        select max(price) from product where categoryName = &apos;电脑&apos;;    d).min(列名)：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算        例如：查询电脑类商品的最低价格？        select min(price) from product where categoryName = &apos;电脑&apos;;    e).avg(列名)：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0        例如：查询电脑类商品的平均价格？        select avg(price) from product where categoryName = &apos;电脑&apos;;        注意：计算记录的总数量时，不包含NULL的记录。              所以如果计算的列中有NULL值，则结果不准确。3.注意：聚合查询的结果，只能包含&quot;聚合结果列&quot;，不要包含其他列，要包含，其结果是无意义的。        聚合的结果是&quot;计算的结果&quot;，跟某行数据无关，所以不能关联显示其它字段。</code></pre><h4 id="03-SQL高级查询-分组："><a href="#03-SQL高级查询-分组：" class="headerlink" title="03.SQL高级查询_分组："></a>03.SQL高级查询_分组：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1.分组：对某列中"相同的值"作为一组，进行分组。分组只是手段，后续经常需要进行汇总：</span><br><span class="line">2.例如：一条语句查询出每种商品的最高价格是多少？</span><br><span class="line"><span class="keyword">SELECT</span> categoryName,<span class="keyword">MAX</span>(price) <span class="keyword">FROM</span> product <span class="keyword">GROUP</span> <span class="keyword">BY</span> categoryName;</span><br><span class="line">练习：查询每种商品的价格的总和</span><br><span class="line"><span class="keyword">SELECT</span> categoryName,<span class="keyword">SUM</span>(price) <span class="keyword">FROM</span> product <span class="keyword">GROUP</span> <span class="keyword">BY</span> categoryName;</span><br><span class="line">练习：查询每种商品的商品数量是多少</span><br><span class="line"><span class="keyword">SELECT</span> categoryName,<span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> product <span class="keyword">GROUP</span> <span class="keyword">BY</span> categoryname;</span><br><span class="line">3.注意：</span><br><span class="line">   1).分组查询的结果字段中，只能包含"分组字段"，"聚合结果字段"。不能再包含其他字段，如果包含，其结果也是无意义的。</span><br><span class="line">4.having子句：</span><br><span class="line">   1).由于where不能对聚合后的结果进行筛选。所以要对聚合后的结果进行筛选，需要使用having子句。</span><br><span class="line">例如：查询每种商品的价格总额，结果保留大于1000元的。</span><br><span class="line"><span class="keyword">select</span> categoryName,<span class="keyword">sum</span>(price) <span class="keyword">from</span> product <span class="keyword">group</span> <span class="keyword">by</span> categoryName <span class="keyword">having</span> <span class="keyword">sum</span>(price) &gt; <span class="number">1000</span>;</span><br><span class="line">5.对多列进行分组：</span><br><span class="line">    收支流水表：trans</span><br><span class="line">    id收支项账户金额</span><br><span class="line">    1工资收入工商银行1000</span><br><span class="line">    2红包收入工商银行500</span><br><span class="line">    3收入交通银行3000</span><br><span class="line">    4支出工商银行300</span><br><span class="line">    5支出交通银行770</span><br><span class="line"></span><br><span class="line">    需求：查询出每个账户的收支总额，分别是多少？</span><br><span class="line">账户收支项总金额</span><br><span class="line">工商银行收入1500</span><br><span class="line">工商银行支出300</span><br><span class="line">交通银行收入3000</span><br><span class="line">交通银行支出770</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">select</span> 账户,收支项,<span class="keyword">sum</span>(金额) <span class="keyword">from</span> trans <span class="keyword">group</span> <span class="keyword">by</span> 账户,收支项;//先按账户分，再按收支项分。</span><br></pre></td></tr></table></figure><h4 id="04-SQL语句的执行顺序："><a href="#04-SQL语句的执行顺序：" class="headerlink" title="04.SQL语句的执行顺序："></a>04.SQL语句的执行顺序：</h4><pre><code>1).from2).where3).group by4).having5).select6).distinct7).order by</code></pre><p>   SQL语句的编写顺序：<br>    select … from …  where … group by … having … order by …;</p><h4 id="05-分页查询："><a href="#05-分页查询：" class="headerlink" title="05.分页查询："></a>05.分页查询：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1).基本语句：<span class="keyword">select</span> * <span class="keyword">from</span> 表名 <span class="keyword">limit</span> M,N;</span><br><span class="line">             M值：从第几条(第一条记录为0)记录开始取。</span><br><span class="line">     N值：取几条记录</span><br><span class="line">2).例如：查询所有的商品，每页显示5条：</span><br><span class="line">第一页：</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">5</span>;</span><br><span class="line">第二页：</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">5</span>,<span class="number">5</span>;</span><br><span class="line">第三页：</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">10</span>,<span class="number">5</span></span><br><span class="line"></span><br><span class="line">固定算法：</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">limit</span> (当前的页数 - <span class="number">1</span>) * 每页显示的条数</span><br><span class="line"><span class="number">3</span>).注意：M值和N值，只要是正数，不会抛异常，可能会返回空结果集。</span><br><span class="line">         但如果是负数，会抛异常。</span><br></pre></td></tr></table></figure><h4 id="06-备份和恢复数据库："><a href="#06-备份和恢复数据库：" class="headerlink" title="06.备份和恢复数据库："></a>06.备份和恢复数据库：</h4><pre><code>1).备份：在要备份的数据库上右键--&gt;备份/导出--&gt;以SQL转储文件备份数据库2).恢复：在SQLYog左侧右键--&gt;导入--&gt;从SQL转储文件导入数据库</code></pre><h4 id="07-SQL的约束："><a href="#07-SQL的约束：" class="headerlink" title="07.SQL的约束："></a>07.SQL的约束：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">1).主键约束：</span><br><span class="line">1).主键的作用：唯一标识表中一条记录。用于作为条件，方便的进行增删改查操作。</span><br><span class="line">2).定义主键：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">pid <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">..其它字段..</span><br><span class="line">..</span><br><span class="line">)</span><br><span class="line"><span class="number">3</span>).一个表中只能有一个主键；</span><br><span class="line"><span class="number">4</span>).一个主键，可以由一个或多个字段组成[很少用]；复合主键，联合主键</span><br><span class="line">客户信息表：将<span class="string">"客户姓名"</span> + <span class="string">"工作单位"</span> 同时作为一个主键</span><br><span class="line">客户姓名工作单位性别年龄</span><br><span class="line">张三人事部男<span class="number">20</span></span><br><span class="line">李四人事部女<span class="number">22</span></span><br><span class="line">张三业务部男<span class="number">23</span></span><br><span class="line">张三人事部男<span class="number">18</span> //错误的数据</span><br><span class="line"><span class="number">5</span>).任何类型的字段都可以做主键。当前使用<span class="built_in">int</span>类型。后期<span class="built_in">varchar</span></span><br><span class="line"><span class="number">6</span>).为某个字段添加了<span class="string">"主键约束"</span>，也同时自动添加：唯一约束、非空约束</span><br><span class="line"><span class="number">7</span>).删除主键约束：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>;</span><br><span class="line">2).自动增长：</span><br><span class="line">1).自动增长：让某列的值根据某个基数，进行自增。这种约束通常用于"主键".</span><br><span class="line">2).添加自动增长约束：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">pid <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">....</span><br><span class="line">)</span><br><span class="line"><span class="number">3</span>).清空表对自动增长列的基数的变化：</span><br><span class="line"><span class="number">1</span>).delete <span class="keyword">from</span> 表名:逐行删除。不改变自动增长的基数。</span><br><span class="line"><span class="number">2</span>).truncate 表名【效率高】：摧毁表，重建表。将自动增长的基数重新设置为<span class="number">1.</span></span><br><span class="line"><span class="number">3</span>).非空约束：<span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="number">1</span>).作用：强制某列的数据不能包含<span class="literal">NULL</span>值；</span><br><span class="line"><span class="number">2</span>).添加非空约束：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">pid <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">pname <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">....</span><br><span class="line">)</span><br><span class="line">如下添加，会抛出异常：</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="literal">null</span>,...);//第二个null是错误，pname字段不允许null值</span><br><span class="line">3).删除非空约束 </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">MODIFY</span> 列名 数据类型[长度] (后面不出现<span class="keyword">not</span> <span class="literal">null</span>约束即可，就表示删除了<span class="keyword">not</span> <span class="literal">NULL</span>约束) </span><br><span class="line"><span class="number">4</span>).唯一约束：<span class="keyword">unique</span></span><br><span class="line"><span class="number">1</span>).作用：表示本列的值是唯一的</span><br><span class="line"><span class="number">2</span>).添加唯一约束：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">pid <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">pname <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">unique</span>,</span><br><span class="line">...</span><br><span class="line">)</span><br><span class="line">   如果向pname字段添加重复的值，数据库会抛出异常。</span><br><span class="line"><span class="number">3</span>).如果字段设置了唯一约束，可以写入<span class="string">"空字符串"</span>，但只能有一条。</span><br><span class="line">   也可以写入<span class="literal">NULL</span>值，可以写入多条。</span><br><span class="line"><span class="number">4</span>).删除唯一约束：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">INDEX</span> 名称;</span><br><span class="line">如果添加唯一约束时，没有设置约束名称，默认是当前字段的字段名</span><br><span class="line">5).主键与唯一约束的区别：</span><br><span class="line">主键：代表：唯一、非空；一个表只能有一个主键；</span><br><span class="line">唯一：只代表：唯一；可以有多个NULL值；一个表可以有多个字段被设置为唯一约束；</span><br><span class="line">5).默认约束：default 值;</span><br><span class="line">1).作用：可以设置某列的默认值，在添加数据时，可以不指定这列的数据，而使用默认值。</span><br><span class="line">2).设置默认约束：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line"><span class="keyword">id</span><span class="built_in">int</span>primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">stuName<span class="built_in">varchar</span>(<span class="number">20</span>)<span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">sex<span class="built_in">char</span>(<span class="number">5</span>)<span class="keyword">default</span> <span class="string">'男'</span></span><br><span class="line">)</span><br><span class="line">在添加时，如果要使用默认值：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="literal">NULL</span>,<span class="string">'bbb'</span>,<span class="keyword">DEFAULT</span>);</span><br><span class="line">3).删除默认约束：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">MODIFY</span> 列名 数据类型[长度](后面不要出现<span class="keyword">default</span>关键字即可)</span><br></pre></td></tr></table></figure><h4 id="08-多表-分表的作用："><a href="#08-多表-分表的作用：" class="headerlink" title="08.多表_分表的作用："></a>08.多表_分表的作用：</h4><pre><code>1.在制作表时要注意：一个表只描述一件事情。如果需要描述多件事情，可以创建多表，然后通过某个字段去引用                    另一个表的数据。这样可以使每个表的数据单独管理，互不影响。2.分表后：    主表：被其它表引用的表；    从表：引用其它表的表；    3.作用：            避免主键冲突，减少数据冗余</code></pre><h4 id="09-多表-表和表之间的关系："><a href="#09-多表-表和表之间的关系：" class="headerlink" title="09.多表_表和表之间的关系："></a>09.多表_表和表之间的关系：</h4><pre><code>1.一对多关系【最常用】：    1).应用场景：客户和订单；分类和商品；部门和员工        客户表:主表                订单表：从表                            外键        ----------------------------------------------------------------------------------------        客户ID    登录名    支付宝            订单ID    订单时间    总金额        客户ID        001    zhangsan  xxx            001    xxx        xxx        001                              002    xxx        xxx        001    2).建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键.2.多对多关系【较常用】：    1).应用场景：订单和商品、用户和角色        订单表                    商品表：        -----------------------------------------------------------------------------------------        订单ID    订单日期   总金额          商品ID    名称    单价            d001    2017-07-04  100            p001    奥利奥    5.5        d002    2017-07-05  200            p002    红牛    4                            p003    啤酒    2.00                    订单_商品_关系表                    订单Id        商品ID    数量    总价                    d001        p001    2    11                    d001        p002    3    12                    d001        p003                        d002        p001    2).建表原则：需要创建第三张表,中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键。3.一对一关系【不建议用】：    1).客户信息表：                        地址表        姓名    性别    年龄    地址ID            id    省    市    区    街道门牌        张三    男    22    01            01    北京    北京    顺义    99号        李四    女    23    02            02    河北    廊坊    安次    88号    ------------------------------------------------------------------------------------------------       合并为一个客户表：        姓名    性别    年龄    省    市    区    街道门牌        张三    男    22    北京    北京    顺义    99号        李四    女    23    河北    廊坊    安次    88号</code></pre><h4 id="10-外键约束："><a href="#10-外键约束：" class="headerlink" title="10.外键约束："></a>10.外键约束：</h4><pre><code>1).作用：设置在&quot;从表&quot;的外键字段上，可以强制外键字段的值必须参考主表中的主键字段的值。2).设置外键约束：    alter table 从表 add [constraint] [外键名称] foreign key (从表外键字段名) references 主表 (主表的主键);3).使用外键目的：    保证数据完整性</code></pre><h4 id="学习目标总结："><a href="#学习目标总结：" class="headerlink" title="学习目标总结："></a>学习目标总结：</h4><p>3，能够使用SQL语句进行排序<br>a，    说出排序语句中的升序和降序关键字</p><pre><code>order by 字段名 ASC(升序-默认) / DESC(降序)</code></pre><p>b，    写出排序语句<br>        select <em> from product order by price desc;<br>4，能够使用聚合函数<br>a，    写出获取总记录数的SQL语句<br>        select count(</em>) from product;<br>b，    写出获取某一列数据总和的SQL语句<br>        select sum(price) from product;<br>c，    写出获取某一列数据平均值的SQL语句<br>        select avg(price) …<br>d，    写出获取某一列数据的最大值的SQL语句<br>        select max(price) …<br>e，    写出获取某一列数据的最小值的SQL语句<br>        select min(price) …<br>5，能够使用SQL语句进行分组查询<br>a，    写出分组的SQL语句<br>        group by 字段名<br>b，    写出分组后条件过滤器的SQL语句<br>        gruup by 字段名 having 聚合函数 条件;<br>6，能够完成数据的备份和恢复<br>    1.备份：在要备份的数据库上右键–&gt;备份/导出–&gt;以SQL转储文件备份数据库<br>    2.恢复：在SQLYog左边右键–&gt;导入–&gt;以SQL转储文件导入数据库。<br>7，能够使用可视化工具连接数据库,操作数据库<br>    使用SQLYog连接数据库。操作数据库</p><p>8，能够说出多表之间的关系及其建表原则<br>a，    说出一对多的应用场景及其建表原则<br>        1).应用场景：客户和订单，分类和商品，部门和员工.<br>        2).在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键.<br>b，    说出多对多的应用场景及其建表原则<br>        1).应用场景：学生和课程、用户和角色<br>        2).需要创建第三张表,中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键.<br>9，能够理解外键约束<br>a，    说出外键约束的作用<br>        作用：强制外键字段的值必须参考主表中主键字段的值。<br>b，    写出创建外键的SQL语句<br>        alter table product add constraint fk_fkname foreign key (categoryid) references category (cid);<br>c，    通过sql语句能够建立多表及其关系<br>        创建表的外键，并且创建外键约束。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;01-SQL高级查询-排序：&quot;&gt;&lt;a href=&quot;#01-SQL高级查询-排序：&quot; class=&quot;headerlink&quot; title=&quot;01.SQL高级查询_排序：&quot;&gt;&lt;/a&gt;01.SQL高级查询_排序：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1.使用的关键字：order
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.top.com/tags/mysql/"/>
    
      <category term="sql" scheme="http://www.top.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>mysql学习</title>
    <link href="http://www.top.com/2017/11/26/mysql01/"/>
    <id>http://www.top.com/2017/11/26/mysql01/</id>
    <published>2017-11-26T06:23:50.000Z</published>
    <updated>2017-12-01T17:23:17.583Z</updated>
    
    <content type="html"><![CDATA[<h4 id="01-数据库的概念："><a href="#01-数据库的概念：" class="headerlink" title="01.数据库的概念："></a>01.数据库的概念：</h4><pre><code>1).数据库的概念：数据库(Database)，就是存储,维护，管理数据的仓库。2).作用：用来存储和管理大量数据的。内部采用了非常便于查询的机制来存储数据，能保证我们在大量数据的情况下         可以很快，并且很准确为我们查询到所需记录。3).什么是数据库管理系统：指一种操作和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理系统访问数据库中表内的数据。</code></pre><h4 id="02-数据库内部的结构："><a href="#02-数据库内部的结构：" class="headerlink" title="02.数据库内部的结构："></a>02.数据库内部的结构：</h4><pre><code>数据库软件：   |--逻辑数据库(跟项目相关)    |--表        |--列        |--行(记录)    |--表    ....   |--逻辑数据库(跟项目相关)   ....</code></pre><h4 id="03-Java和数据库的对应关系："><a href="#03-Java和数据库的对应关系：" class="headerlink" title="03.Java和数据库的对应关系："></a>03.Java和数据库的对应关系：</h4><p>java        数据库</p><pre><code>项目        逻辑数据库类        表类中成员属性    表的字段(列)属性的数据类型    字段的数据类型对象        表中的一行记录</code></pre><h4 id="04-常见的数据库管理系统"><a href="#04-常见的数据库管理系统" class="headerlink" title="04.常见的数据库管理系统"></a>04.常见的数据库管理系统</h4><pre><code>MYSQL    ：开源免费的数据库，小型的数据库.已经被Oracle收购了.MySQL6.x版本也开始收费。Oracle    ：收费的大型数据库，Oracle公司的产品。Oracle收购SUN公司，收购MYSQL。DB2：IBM公司的数据库产品,收费的。常应用在银行系统中.SQLServer：MicroSoft 公司收费的中型的数据库。C#、.net等语言常使用。SyBase    ：已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。SQLite    : 嵌入式的小型数据库，应用在手机端。常用数据库：MYSQL，Oracle．这里使用MySQL数据库。MySQL中可以有多个数据库，数据库是真正存储数据的地方。</code></pre><h4 id="05-MySQL的安装和客户端连接："><a href="#05-MySQL的安装和客户端连接：" class="headerlink" title="05.MySQL的安装和客户端连接："></a>05.MySQL的安装和客户端连接：</h4><pre><code>1.连接MySQL服务器端：    1).使用命令行：        mysql -uroot -p密码 (回车)    2).使用SQLYog客户端:        直接启动，在连接界面填写：服务器IP，端口，用户名、密码，点击：连接</code></pre><h4 id="06-SQL语句的介绍："><a href="#06-SQL语句的介绍：" class="headerlink" title="06.SQL语句的介绍："></a>06.SQL语句的介绍：</h4><pre><code>1.普通话：标准的SQL语言，各个数据库厂商必须遵守的。2.方言：个数据库厂商自己开发的基于的SQL的一些新功能的语法。只在自己的数据库        上有效。</code></pre><h4 id="07-SQL语言的分类："><a href="#07-SQL语言的分类：" class="headerlink" title="07.SQL语言的分类："></a>07.SQL语言的分类：</h4><p>（结构化查询语言）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.DDL:数据定义语言,来定义数据库对象：逻辑数据库，表，列等。关键字：</span><br><span class="line"><span class="keyword">create</span>（创建），<span class="keyword">alter</span>（修改），<span class="keyword">drop</span>（删除）等</span><br><span class="line"><span class="number">2.</span>DCL:数据控制语言.用来定义数据库的访问权限和安全级别，及创建用户。</span><br><span class="line"><span class="keyword">grant</span> ,<span class="keyword">revoke</span>,if.</span><br><span class="line"><span class="number">3.</span>DML【重点掌握】:数据操作语言。用来对数据库中表的<span class="string">"记录"</span>进行更新。</span><br><span class="line">关键字：<span class="keyword">insert</span>（添加），<span class="keyword">delete</span>（删除），<span class="keyword">update</span>（修改）等</span><br><span class="line"><span class="number">4.</span>DQL【重点掌握】:数据查询语言。用来查询数据库中表的<span class="string">"记录"</span>。</span><br><span class="line">关键字：<span class="keyword">select</span>，<span class="keyword">from</span>，<span class="keyword">where</span>,groud <span class="keyword">by</span> ,<span class="keyword">order</span> <span class="keyword">by</span>,<span class="keyword">having</span> ,<span class="keyword">limit</span> 聚合函数等</span><br></pre></td></tr></table></figure><h4 id="08-SQL通用语法："><a href="#08-SQL通用语法：" class="headerlink" title="08.SQL通用语法："></a>08.SQL通用语法：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.SQL语句可以单行或多行书写，以分号结尾</span><br><span class="line">2.可使用空格和缩进来增强语句的可读性</span><br><span class="line">3.MySQL数据库的SQL语句不区分大小写，关键字建议使用大写</span><br><span class="line">  例如：<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>。</span><br><span class="line"><span class="number">4.</span>注释：</span><br><span class="line"><span class="number">1</span>).#单行注释</span><br><span class="line"><span class="number">2</span>).<span class="comment">--(空格)单行注释</span></span><br><span class="line"><span class="number">3</span>).<span class="comment">/* ... */</span> 多行注释</span><br></pre></td></tr></table></figure><h4 id="09-数据库操作的相关语句："><a href="#09-数据库操作的相关语句：" class="headerlink" title="09.数据库操作的相关语句："></a>09.数据库操作的相关语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.创建数据库：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名 <span class="built_in">character</span> <span class="keyword">set</span> 字符集;</span><br><span class="line">2.查看所有数据库：</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line">3.查看某个数据库的定义的信息:</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> 数据库名;</span><br><span class="line">4.删除数据库：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 数据库名;</span><br><span class="line">5.查看当前正在使用的数据库：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">database</span>();</span><br><span class="line">6.切换数据库：</span><br><span class="line"><span class="keyword">use</span> 数据库名；</span><br></pre></td></tr></table></figure><h4 id="10-表操作的相关语句："><a href="#10-表操作的相关语句：" class="headerlink" title="10.表操作的相关语句："></a>10.表操作的相关语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.创建表：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">字段名<span class="number">1</span>  数据类型[长度]  [约束],</span><br><span class="line">字段名<span class="number">2</span>  数据类型[长度]  [约束],</span><br><span class="line">...</span><br><span class="line">字段名n  数据类型[长度]  [约束]</span><br><span class="line">);</span><br><span class="line">   例如创建一个学员信息表，存储：学号、姓名、性别、年龄</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">stuNo <span class="built_in">int</span>,</span><br><span class="line">stuName<span class="built_in">varchar</span>(<span class="number">200</span>),</span><br><span class="line">stuSex<span class="built_in">char</span>(<span class="number">5</span>),</span><br><span class="line">stuAge<span class="built_in">int</span></span><br><span class="line">);</span><br><span class="line">2.Java的数据类型与MySQL中的数据类型</span><br><span class="line">java数据类型MySQL数据类型</span><br><span class="line">  <span class="comment">------------------------------------------------------------</span></span><br><span class="line">        整数:</span><br><span class="line">intint</span><br><span class="line"></span><br><span class="line">小数：</span><br><span class="line">float/doublefloat/double/decimal(m,n)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">字符：</span><br><span class="line">charchar</span><br><span class="line"></span><br><span class="line">字符串：</span><br><span class="line">Stringchar(定长)/varchar(不定长)</span><br><span class="line">在Java中char表示一个字符；而MySQL中的char表示：可变的字符串；</span><br><span class="line"></span><br><span class="line">        =============================================================================================================</span><br><span class="line">在MySQL中char和varchar的区别：</span><br><span class="line">1.char:定长字符串：例如定义字段为：char(5):</span><br><span class="line">   表示最多存储5个字符，如果不足5个字符，剩下的用空字符填充。</span><br><span class="line">   例如：定义char(5)<span class="comment">--&gt;要存储字符串"abc"--&gt;在硬盘上存储的格式--&gt;"abc  "</span></span><br><span class="line">        要存储字符串"abcd"<span class="comment">--&gt;在硬盘上存储的格式--&gt;"abcd "</span></span><br><span class="line"></span><br><span class="line">2.varchar:不定长字符串：例如定义字段为：</span><br><span class="line">varchar(5)表示最多存储5个字符，如果不足5个字符，不填充空字符。</span><br><span class="line">例如：定义varchar(5)<span class="comment">--&gt;要存储字符串"abc"--&gt;在硬盘上存储的格式--&gt;"abc"</span></span><br><span class="line">     要存储字符串"abcd"<span class="comment">--&gt;在硬盘上存储的格式--&gt;"abcd"</span></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.char类型的在查询效率上要高于varchar，所以，尽量选择char类型；</span><br><span class="line">2.对于字段的平均长度相同或者变化不大的数据，优先使用char类型。</span><br><span class="line">例如：手机号码、身份证号、银行卡号....</span><br><span class="line">3.对于字段的平均长度相差比较大的数据，建议使用varchar类型。</span><br><span class="line">例如：个人介绍......</span><br><span class="line"></span><br><span class="line">=============================================================================================================</span><br><span class="line">日期类型：</span><br><span class="line">String</span><br><span class="line">Datedate(日期常用)范围：YYYY-MM-DD 1000-01-01~9999-12-3</span><br><span class="line">datetime【常用】(日期和时间)范围：YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</span><br><span class="line">大文本：</span><br><span class="line">StringText</span><br><span class="line"></span><br><span class="line">文本二进制</span><br><span class="line">byte[]binary</span><br><span class="line"></span><br><span class="line">二进制(图片，视频)</span><br><span class="line">byte[]Blob</span><br><span class="line">3.查看数据库中的所有表：</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line">4.查看表结构：</span><br><span class="line">desc 表名;</span><br><span class="line">5.删除表：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br><span class="line">6.修改表：</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 类型(长度) [约束];</span><br><span class="line">作用：修改表添加列. </span><br><span class="line">例如：</span><br><span class="line">#1，为分类表添加一个新的字段为分类描述 varchar(20)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">category</span> <span class="keyword">ADD</span> <span class="string">`desc`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">modify</span> 列名 类型(长度) 约束;</span><br><span class="line">作用：修改表修改列的类型长度及约束.</span><br><span class="line">例如：</span><br><span class="line">#2, 为分类表的描述字段进行修改，类型varchar(50) 添加约束 not null</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">category</span> <span class="keyword">MODIFY</span> <span class="string">`desc`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">change</span> 旧列名 新列名 类型(长度) 约束; </span><br><span class="line">作用：修改表修改列名.</span><br><span class="line">例如：</span><br><span class="line">#3, 为分类表的分类名称字段进行更换更换为 snamesname varchar(30)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">category</span> <span class="keyword">CHANGE</span> <span class="string">`desc`</span>description <span class="built_in">VARCHAR</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 列名;</span><br><span class="line">作用：修改表删除列.</span><br><span class="line">例如：</span><br><span class="line">#4, 删除分类表中snamename这列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">category</span> <span class="keyword">DROP</span> description;</span><br><span class="line"></span><br><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> 表名 <span class="keyword">to</span> 新表名;</span><br><span class="line">作用：修改表名</span><br><span class="line">例如：</span><br><span class="line">#5, 为分类表category改名成 category2</span><br><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> <span class="keyword">category</span> <span class="keyword">TO</span> category2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="built_in">character</span> <span class="keyword">set</span> 字符集;</span><br><span class="line">作用：修改表的字符集</span><br><span class="line">例如：</span><br><span class="line">#6, 为分类表 category 的编码表进行修改，修改成 gbk</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">category</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> gbk;</span><br></pre></td></tr></table></figure><h4 id="11-表记录操作相关的语句："><a href="#11-表记录操作相关的语句：" class="headerlink" title="11.表记录操作相关的语句："></a>11.表记录操作相关的语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">1.添加数据：<span class="keyword">insert</span> <span class="keyword">into</span></span><br><span class="line">两种格式：</span><br><span class="line"><span class="number">1.</span><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>，.....，值n)<span class="comment">--全字段添加</span></span><br><span class="line">  注意：</span><br><span class="line">  <span class="number">1</span>).后面值列表中的数量必须跟表中列的数量匹配，而且顺序也要匹配。</span><br><span class="line">  <span class="number">2</span>).值：数值类型，可以不用单引号(用也可以)</span><br><span class="line">         字符串类型，一定要使用单引号。</span><br><span class="line">        <span class="number">2.</span><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段<span class="number">1</span>,字段<span class="number">2</span>,.....,字段n) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,....,值n)<span class="comment">--部分字段添加，剩余字段添加：NULL</span></span><br><span class="line">  注意：</span><br><span class="line">  <span class="number">1</span>).字段列表：可以是表的部分字段，也可以不按照定义顺序；</span><br><span class="line">  <span class="number">2</span>).值列表：必须跟字段列表的数量和顺序要匹配。</span><br><span class="line">  <span class="number">3</span>).未指定的字段，添加：<span class="literal">NULL</span>值。(前提是：字段允许<span class="literal">NULL</span>值)</span><br><span class="line"><span class="number">2.</span>修改数据：<span class="keyword">update</span></span><br><span class="line">格式：<span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span> = 值<span class="number">1</span> , 字段名<span class="number">2</span> = 值<span class="number">2</span> , .... , 字段名n = 值n   <span class="keyword">where</span> 条件；</span><br><span class="line"><span class="number">3.</span>删除数据：<span class="keyword">delete</span> <span class="keyword">from</span></span><br><span class="line">格式：<span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br><span class="line">  清空表：</span><br><span class="line">1).delete from 表名;逐行删除，效率低；不清空auto_increment记录数</span><br><span class="line">2).truncate 表名;先摧毁表，然后按照原结构再创建一个新表，效率高；auto_increment将置为零，从新开始</span><br><span class="line"></span><br><span class="line">4.查询数据：<span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段的筛选条件</span><br><span class="line"><span class="number">1.</span>简单查询：</span><br><span class="line"><span class="number">1</span>).查询所有字段的所有记录：</span><br><span class="line"><span class="keyword">select</span> pid,pname,price,categoryName <span class="keyword">from</span> product;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product;</span><br><span class="line">2).查询部分字段的所有记录：</span><br><span class="line"><span class="keyword">select</span> pname,price <span class="keyword">from</span> product;</span><br><span class="line">3).使用别名：</span><br><span class="line">a).列别名：</span><br><span class="line"><span class="keyword">SELECT</span> pname <span class="keyword">AS</span> <span class="string">'商品名称'</span> , price <span class="keyword">AS</span> <span class="string">'价格'</span> <span class="keyword">FROM</span> product;</span><br><span class="line">b).表别名：</span><br><span class="line"><span class="keyword">SELECT</span> p.pname,p.price <span class="keyword">FROM</span> product p;//一般在多表中使用别名</span><br><span class="line">4).去掉重复值</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> price <span class="keyword">FROM</span> product;</span><br><span class="line">5).对查询结果进行运算：</span><br><span class="line">例如：将所有查询结果的商品的价格加100显示：</span><br><span class="line"><span class="keyword">select</span> pname,price + <span class="number">100</span> <span class="keyword">from</span> product;</span><br><span class="line">        注意：只对查询结果进行更改，原数据没有更改。</span><br><span class="line">2.条件查询：</span><br><span class="line">1).比较运算符：</span><br><span class="line">1)."&gt;":大于。例如：查询价格大于2000元的商品--针对数值类型查询</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price &gt; <span class="number">2000</span>;</span><br><span class="line">2)."&lt;":小于。例如：查询价格小于2000元的商品--针对数值类型查询</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price &lt; <span class="number">2000</span>;</span><br><span class="line">3)."&gt;=":大于等于。例如：查询价格大于等于2000元的商品--针对数值类型查询</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price &gt;= <span class="number">2000</span>;</span><br><span class="line">4)."&lt;=":小于等于。例如：查询价格小于等于2000元的商品--针对数值类型查询</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price &lt;= <span class="number">2000</span>;</span><br><span class="line">5)."&lt;&gt;":不等于。例如：查询价格不等于2000元的商品--针对各种类型</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price &lt;&gt; <span class="number">2000</span>;</span><br><span class="line">   "!=":不等于<span class="comment">--针对各种类型</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price != <span class="number">2000</span>;</span><br><span class="line">6)."=" :等于.例如：查询价格等于2000元的商品<span class="comment">--针对各种类型</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price = <span class="number">2000</span>;</span><br><span class="line">2).逻辑运算符：</span><br><span class="line">1).and : 语义：并且</span><br><span class="line">例如：查询所有商品价格大于2000元的电脑类商品</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price &gt; <span class="number">2000</span> <span class="keyword">and</span> categoryName = <span class="string">'电脑'</span>;</span><br><span class="line">2).or  : 语义：或者</span><br><span class="line">例如：查询所有商品价格大于2000元，或者价格低于1000元的所有商品</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price &gt; <span class="number">2000</span> <span class="keyword">or</span> price &lt; <span class="number">1000</span>;</span><br><span class="line">3).not : 语义：非</span><br><span class="line">例如：查询商品价格不大于2000元的所有商品</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">not</span>(price &gt; <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">注意：如果多个and和or运算，中间不要加逗号，可以使用()改变运算顺序。</span><br><span class="line">例如：查询所有价格大于2000元的电脑类商品或者服装类商品</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price &gt; <span class="number">2000</span> <span class="keyword">and</span> (categoryName = <span class="string">'电脑'</span> <span class="keyword">or</span> categoryName = <span class="string">'服装'</span>);</span><br><span class="line">3).范围查询：between ... and ...(可以用于数值类型，也可以用于日期类型)</span><br><span class="line">1).用于查询数值范围：between(包含)....and(包含)...</span><br><span class="line">   例如：查询价格在1000元(包含)到2000元(包含)之间的所有商品</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price &gt;= <span class="number">1000</span> <span class="keyword">and</span> price &lt;= <span class="number">2000</span>;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="keyword">between</span> <span class="number">1000</span> <span class="keyword">and</span> <span class="number">2000</span>;</span><br><span class="line">2).用于查询日期范围：</span><br><span class="line">    例如：查询生产日期在2017年1月份的所有商品</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> proDate <span class="keyword">between</span> <span class="string">'2017-01-01'</span> <span class="keyword">and</span> <span class="string">'2017-01-31'</span>;</span><br><span class="line">4).多个值的判断：in(值列表)</span><br><span class="line">例如：查询商品价格为200元，500元，1000元，2000元的商品信息</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price = <span class="number">200</span> <span class="keyword">or</span> price = <span class="number">500</span> <span class="keyword">or</span> price = <span class="number">1000</span> <span class="keyword">or</span> price = <span class="number">2000</span>;</span><br><span class="line">或者使用in查询</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="keyword">in</span> (<span class="number">200</span>,<span class="number">500</span>,<span class="number">1000</span>,<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">5).模糊查询：like 两个通配符：1)"%" : 任意的0到多个字符；2)"_":任意的1个字符</span><br><span class="line">例如：查询商品名称中包含"花"的商品信息</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">'%花%'</span>;</span><br><span class="line">      查询商品名称中以"花"字开头的商品：</span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">'花%'</span>;</span><br><span class="line">      商品名称以"花花"开头，全名是四个字的商品：</span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">'花花__'</span>;</span><br><span class="line">6).查询空字段：</span><br><span class="line">1).添加一条记录时，不添加的字段可以指定为NULL值，例如：</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="number">14</span>,<span class="string">'果10'</span>,<span class="number">200</span>,<span class="string">'食品'</span>,<span class="literal">NULL</span>);</span><br><span class="line">   要查询所有"生产日期"没有添加的所有商品：</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> proDate <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line">3).添加一条记录：</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="number">15</span>,<span class="string">'果11'</span>,<span class="number">300</span>,<span class="string">''</span>,<span class="literal">null</span>);</span><br><span class="line">   要查询出来这条记录：</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> proDate = <span class="string">''</span>;</span><br></pre></td></tr></table></figure><p>##### </p><p>##### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;01-数据库的概念：&quot;&gt;&lt;a href=&quot;#01-数据库的概念：&quot; class=&quot;headerlink&quot; title=&quot;01.数据库的概念：&quot;&gt;&lt;/a&gt;01.数据库的概念：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1).数据库的概念：数据库(Database)，就是存储,维
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.top.com/tags/mysql/"/>
    
      <category term="sql" scheme="http://www.top.com/tags/sql/"/>
    
  </entry>
  
</feed>
